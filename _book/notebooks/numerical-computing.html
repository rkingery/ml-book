<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Machine Learning For The 2020s - 2&nbsp; Numerical Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notebooks/vectorization.html" rel="next">
<link href="../notebooks/basic-math.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Numerical Computation</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Machine Learning For The 2020s</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/basic-math.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Basic Math</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/numerical-computing.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Numerical Computation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/vectorization.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Arrays and Vectorization</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/basic-calculus.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Basic Calculus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/linear-systems.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Systems of Linear Equations</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/vector-spaces.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Vector Spaces</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/matrix-algebra.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Matrix Algebra</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/probability.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Probability Distributions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/multivariate-probability.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Multivariate Distributions</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#integers" id="toc-integers" class="nav-link active" data-scroll-target="#integers">Integers</a>
  <ul class="collapse">
  <li><a href="#basics" id="toc-basics" class="nav-link" data-scroll-target="#basics">Basics</a></li>
  <li><a href="#representing-integers" id="toc-representing-integers" class="nav-link" data-scroll-target="#representing-integers">Representing Integers</a></li>
  </ul></li>
  <li><a href="#floats" id="toc-floats" class="nav-link" data-scroll-target="#floats">Floats</a>
  <ul class="collapse">
  <li><a href="#basics-1" id="toc-basics-1" class="nav-link" data-scroll-target="#basics-1">Basics</a></li>
  <li><a href="#representing-floats" id="toc-representing-floats" class="nav-link" data-scroll-target="#representing-floats">Representing Floats</a></li>
  <li><a href="#double-precision" id="toc-double-precision" class="nav-link" data-scroll-target="#double-precision">Double Precision</a></li>
  <li><a href="#common-floating-point-pitfalls" id="toc-common-floating-point-pitfalls" class="nav-link" data-scroll-target="#common-floating-point-pitfalls">Common Floating Point Pitfalls</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-body" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Numerical Computation</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In this lesson I’ll discuss the basics of numerical computation, specifically what integers and floating point numbers are and how they’re represented on a computer. This may seem too basic to mention, but it’s actually very important. There’s a lot of subtlety involved. Let’s get started.</p>
<div class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> utils.math_ml <span class="im">import</span> <span class="op">*</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># this makes every line of a cell print instead of just the last line</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> IPython.core.interactiveshell <span class="im">import</span> InteractiveShell</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>InteractiveShell.ast_node_interactivity <span class="op">=</span> <span class="st">"all"</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="integers" class="level1">
<h1>Integers</h1>
<section id="basics" class="level2">
<h2 class="anchored" data-anchor-id="basics">Basics</h2>
<p>Recall the <strong>integers</strong> are whole numbers that can be positive, negative, or zero. Examples are 5, 100151, 0, -72, etc. The set of all integers is commonly denoted by the symbol <span class="math inline">\(\mathbb{Z}\)</span>.</p>
<p>In python, integers (ints for short) are builtin objects of type <code>int</code> that more or less follow the rules that integers in math follow.</p>
<p>Among other things, the following operations can be performed with integers: - Addition: <span class="math inline">\(2 + 2 = 4\)</span>. - Subtraction: <span class="math inline">\(2 - 5 = -3\)</span>. - Multiplication: <span class="math inline">\(3 \times 3 = 9\)</span> (in python this is the <code>*</code> operator, e.g.&nbsp;<code>3 * 3 = 9</code>) - Exponentiation: <span class="math inline">\(2^3 = 2 \times 2 \times 2 = 8\)</span> (in python this is the <code>**</code> operator, e.g.&nbsp;<code>2 ** 3 = 8</code>). - Remainder (or Modulo): the remainder of 10 when divided by 3 is 1, written <span class="math inline">\(10 \text{ mod } 3 = 1\)</span> (in python this is the <code>%</code> operator, e.g.&nbsp;<code>10 % 3 = 1</code>).</p>
<p>If any of these operations are applied to two integers, the output will itself always be an integer.</p>
<p>Here are a few examples.</p>
<div class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">-</span> <span class="dv">5</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dv">10</span> <span class="op">%</span> <span class="dv">3</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">**</span> <span class="dv">3</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>4</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>-3</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>9</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>1</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>8</code></pre>
</div>
</div>
<p>What about division? You can’t always divide two integers and get another integer. What you have to do instead is called integer division. Here you divide the two numbers and then round the answer down to the nearest whole number. Since <span class="math inline">\(5 \div 2 = 2.5\)</span>, the nearest rounded down integer is 2.</p>
<p>In math, this “nearest rounded down integer” 2 is usually called the <strong>floor</strong> of 2.5, and represented with the funny symbol <span class="math inline">\(\lfloor 2.5 \rfloor.\)</span> Using this notation we can write the above integer division as <span class="math display">\[\big\lfloor \frac{5}{2} \big\rfloor = 2.\]</span></p>
<p>In python, integer division is done using the <code>//</code> operator, e.g.&nbsp;<code>5 // 2 = 2</code>. I’ll usually write <span class="math inline">\(5 \ // \ 2\)</span> instead of <span class="math inline">\(\big\lfloor \frac{5}{2} \big\rfloor\)</span> when it makes sense, <span class="math display">\[5 \ // \ 2 = \big\lfloor \frac{5}{2} \big\rfloor = 2.\]</span></p>
<div class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span> <span class="op">//</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="4">
<pre><code>2</code></pre>
</div>
</div>
<p>We can also do regular division <code>/</code> with ints, but the output will <em>not</em> be an integer even if the answer should be, e.g.&nbsp;<code>4 / 2</code>. Only integer division is guaranteed to return an integer. I’ll get to this shortly.</p>
<div class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span>(<span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>2.0</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="5">
<pre><code>float</code></pre>
</div>
</div>
<div class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">type</span> (<span class="dv">4</span> <span class="op">//</span> <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>2</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="6">
<pre><code>int</code></pre>
</div>
</div>
<p>Division by zero is of course undefined for both division and integer division. In python it will always raise a <code>ZeroDivisionError</code> like so.</p>
<div class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">/</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ZeroDivisionError: division by zero</code></pre>
</div>
</div>
<div class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="op">//</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-error">
<pre><code>ZeroDivisionError: integer division or modulo by zero</code></pre>
</div>
</div>
</section>
<section id="representing-integers" class="level2">
<h2 class="anchored" data-anchor-id="representing-integers">Representing Integers</h2>
<p>Just like every other data type, on a computer integers are actually represented internally as a sequence of bits. A <strong>bit</strong> is a “binary digit”, 0 or 1. A sequence of bits is just a sequence of zeros and ones, e.g.&nbsp;0011001010 or 1001001.</p>
<p>The number of bits used to represent a piece of data is called its <strong>word size</strong>. If we use a word size of <span class="math inline">\(n\)</span> bits to represent an integer, then there are <span class="math inline">\(2^n\)</span> possible integer values we can represent.</p>
<p>If integers could only be positive or zero, representing them with bits would be easy. We could just convert them to binary and that’s it. To convert a non-negative integer to binary, we just need to keep dividing it by 2 and recording its remainder (0 or 1) at each step. The binary form is then just the sequence of remainders, written right to left. More generally, the binary sequence of some arbitrary number <span class="math inline">\(x\)</span> is the sequence of coefficients <span class="math inline">\(b_k=0,1\)</span> in the sum</p>
<p><span class="math display">\[x = \sum_{k=-\infty}^\infty b_k 2^k = \cdots + b_2 2^2 + b_1 2^1 + b_0 2^0 + b_{-1} 2^{-1} + b_{-2} 2^{-2} + \cdots.\]</span></p>
<p>Here’s an example. Suppose we wanted to represent the number <span class="math inline">\(12\)</span> in binary. 1. <span class="math inline">\(12 \ // \ 2 = 6\)</span> with a remainder of <span class="math inline">\(0 = 12 \text{ mod } 2\)</span>, so the first bit from the right is then <span class="math inline">\(0\)</span>. 2. <span class="math inline">\(6 \ // \ 2 = 3\)</span> with a remainder of <span class="math inline">\(0 = 6 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(0\)</span>. 3. <span class="math inline">\(3 \ // \ 2 = 1\)</span> with a remainder of <span class="math inline">\(1 = 3 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(1\)</span>. 4. <span class="math inline">\(1 \ // \ 2 = 0\)</span> with a remainder of <span class="math inline">\(1 = 1 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(1\)</span>.</p>
<p>So the binary representation of <span class="math inline">\(12\)</span> is <span class="math inline">\(1100\)</span>, which is the sequence of coefficients in the sum</p>
<p><span class="math display">\[12 = 1 \cdot 2^{3} + 1 \cdot 2^{2} + 0 \cdot 2^{1} + 0 \cdot 2^{0}.\]</span></p>
<p>Rather than keep doing these by hand, you can quickly convert a number to binary in python by using <code>bin</code>. It’ll return a string representing the binary sequence of that number, prepended with the special prefix <code>0b</code>. To get back to the integer from, use <code>int</code>, passing in a base of <code>2</code>.</p>
<div class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">bin</span>(<span class="dv">12</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="9">
<pre><code>'0b1100'</code></pre>
</div>
</div>
<div class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">int</span>(<span class="st">'0b110'</span>, <span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="10">
<pre><code>6</code></pre>
</div>
</div>
<p>This representation works fine for non-negative integers, also called the <strong>unsigned integers</strong> in computer science. To represent an unsigned integer with <span class="math inline">\(n\)</span> bits, just get its binary form and prepend it with enough zeros on the left until all <span class="math inline">\(n\)</span> bits are used. For example, if we used 8-bit unsigned integers then <span class="math inline">\(n=8\)</span>, hence representing the number <span class="math inline">\(12\)</span> would look like <span class="math inline">\(00000110\)</span>. Simple, right?</p>
<p>Unsigned ints work fine if we never have to worry about negative numbers. But in general we do. These are called the <strong>signed integers</strong> in computer science. To represent signed ints, we need to use one of the bits to represent the sign. What we can do is reserve the left-most bit for the sign, <span class="math inline">\(0\)</span> if the integers is positive or zero, <span class="math inline">\(1\)</span> if the integer is negative.</p>
<p>For example, if we used 8-bit <em>signed</em> integers to represent <span class="math inline">\(12\)</span>, we’d again write <span class="math inline">\(00000110\)</span>, exactly as before. But this time it’s understood that left-most <span class="math inline">\(0\)</span> is encoding the fact that <span class="math inline">\(12\)</span> is positive. If instead we wanted to represent the number <span class="math inline">\(-12\)</span> we’d need to flip that bit to a <span class="math inline">\(1\)</span>, so we’d get <span class="math inline">\(10000110\)</span>.</p>
<p>Let’s now do an example of a simple integer system. Consider the system of 4-bit signed ints. In this simple system, <span class="math inline">\(n=4\)</span> is the word size, and an integer <span class="math inline">\(x\)</span> is represented with the sequence of bits</p>
<p><span class="math display">\[x \equiv sb_1b_2b_3,\]</span></p>
<p>where <span class="math inline">\(s\)</span> is the sign bit and <span class="math inline">\(b_1b_2b_3\)</span> are the remaining 3 bits allowed to represent the numerical digits. This system can represent <span class="math inline">\(2^4=16\)</span> possible values in the range <span class="math inline">\([-2^3+1,2^3-1] = [-8,7]\)</span>, given in the following table:</p>
<table class="table">
<thead>
<tr class="header">
<th>Integer</th>
<th>Representation</th>
<th>Integer</th>
<th>Representation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-0</td>
<td>1000</td>
<td>+0</td>
<td>0000</td>
</tr>
<tr class="even">
<td>-1</td>
<td>1001</td>
<td>1</td>
<td>0001</td>
</tr>
<tr class="odd">
<td>-2</td>
<td>1010</td>
<td>2</td>
<td>0010</td>
</tr>
<tr class="even">
<td>-3</td>
<td>1011</td>
<td>3</td>
<td>0011</td>
</tr>
<tr class="odd">
<td>-4</td>
<td>1100</td>
<td>4</td>
<td>0100</td>
</tr>
<tr class="even">
<td>-5</td>
<td>1101</td>
<td>5</td>
<td>0101</td>
</tr>
<tr class="odd">
<td>-6</td>
<td>1110</td>
<td>6</td>
<td>0110</td>
</tr>
<tr class="even">
<td>-7</td>
<td>1111</td>
<td>7</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p>Note the presence of <span class="math inline">\(-0 \equiv 1110\)</span> in the upper left. This is because the system as I’ve defined it leaves open the possibility of two zeros, <span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>, since for zero the sign bit is redundant. A way to get around this is to encode the negative numbers slightly differently, by not just setting the sign bit to one, but also inverting the remaining bits and subtracting one from them. This is called the <strong>two’s complement representation</strong>. It’s how most languages, including python, actually represent integers. I won’t go into this representation in any depth, except to say that it gets rid of the need for <span class="math inline">\(-0\)</span> and replaces it with <span class="math inline">\(-2^{n-1}\)</span>.</p>
<p>Here’s what that table looks like for 4-bit integers. It’s almost the same, except there’s no <span class="math inline">\(-0\)</span>, instead a <span class="math inline">\(-8\)</span>. Notice the positive integers look exactly the same. It’s only the negative integers that look different. For them, the right three bits get inverted and added with a one.</p>
<table class="table">
<thead>
<tr class="header">
<th>Integer</th>
<th>Two’s Complement</th>
<th>Integer</th>
<th>Two’s Complement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-1</td>
<td>1111</td>
<td>0</td>
<td>0000</td>
</tr>
<tr class="even">
<td>-2</td>
<td>1110</td>
<td>1</td>
<td>0001</td>
</tr>
<tr class="odd">
<td>-3</td>
<td>1101</td>
<td>2</td>
<td>0010</td>
</tr>
<tr class="even">
<td>-4</td>
<td>1100</td>
<td>3</td>
<td>0011</td>
</tr>
<tr class="odd">
<td>-5</td>
<td>1011</td>
<td>4</td>
<td>0100</td>
</tr>
<tr class="even">
<td>-6</td>
<td>1010</td>
<td>5</td>
<td>0101</td>
</tr>
<tr class="odd">
<td>-7</td>
<td>1001</td>
<td>6</td>
<td>0110</td>
</tr>
<tr class="even">
<td>-8</td>
<td>1000</td>
<td>7</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p>It’s worth visualizing what integers look like on the number line, if for nothing else than to compare it with what floats look like later on. Below I’ll plot what a 6-bit signed integer system would look like. Such a system should go from -32 to 31. I’ll to use the helper function <code>plot_number_dist</code> to do the plotting. As you’d expect, you just see a bunch of equally spaced points from -32 to 31.</p>
<div class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>six_bit_ints <span class="op">=</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>), <span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>plot_number_dist(six_bit_ints, title<span class="op">=</span><span class="ss">f'Distribution of </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">-bit Signed Ints'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="numerical-computing_files/figure-html/cell-12-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>In python, integers are represented by default using a much bigger word size of <span class="math inline">\(n=64\)</span> bits, called <strong>long</strong> integers, or <strong>int64</strong> for short. This means (using two’s complement) we can represent <span class="math inline">\(2^{64}=18446744073709551616\)</span> possible integer values in the range <span class="math inline">\([-2^{63}, 2^{63}-1]\)</span>.</p>
<p>You can see from this that 64-bit integers have a minimum integer allowed and a maximum integer allowed, which are</p>
<p><span class="math display">\[\text{min_int}=-2^{63}=-9223372036854775808, \qquad \text{max_int}=2^{63}-1=9223372036854775807.\]</span></p>
<p>What I’ve said is technically only exactly true in older versions of pythons as well as other programming languages like C. It turns out newer versions of python have a few added tricks that allow you to represent essentially arbitrarily large integers. You can see this by comparing it to numpy’s internal int64 representation, which uses the C version. A numpy int64 outside the valid range will throw an overflow error.</p>
<div class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>min_int <span class="op">=</span> <span class="op">-</span><span class="dv">2</span> <span class="op">**</span> <span class="dv">63</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>max_int <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> <span class="dv">63</span> <span class="op">-</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>min_int <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>np.int64(min_int <span class="op">-</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="13">
<pre><code>-9223372036854775809</code></pre>
</div>
<div class="cell-output cell-output-error">
<pre><code>OverflowError: Python int too large to convert to C long</code></pre>
</div>
</div>
<div class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>max_int <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>np.int64(max_int <span class="op">+</span> <span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="14">
<pre><code>9223372036854775808</code></pre>
</div>
<div class="cell-output cell-output-error">
<pre><code>OverflowError: Python int too large to convert to C long</code></pre>
</div>
</div>
</section>
</section>
<section id="floats" class="level1">
<h1>Floats</h1>
<section id="basics-1" class="level2">
<h2 class="anchored" data-anchor-id="basics-1">Basics</h2>
<p>What if we want to represent decimal numbers or fractions instead of whole numbers, like <span class="math inline">\(1.2\)</span> or <span class="math inline">\(0.99999\)</span>, or even irrational numbers like <span class="math inline">\(\pi=3.1415926\dots\)</span>? To do this we need a new system of numbers that I’ll call floating point numbers, or <strong>floats</strong>, for reasons I’ll explain soon. Floats will be a computer’s best attempt to represent the real numbers <span class="math inline">\(\mathbb{R}\)</span>. They’ll represent real numbers only approximately with some specified precision.</p>
<p>In python, floats are builtin objects of type <code>float</code>. Floats obey pretty much the same operations that integers do with some minor exceptions: - Addition: <span class="math inline">\(1.2 + 4.3 = 5.5\)</span>. - Subtraction: <span class="math inline">\(1.2 - 4.3 = -3.1\)</span>. - Multiplication: <span class="math inline">\(1.2 \times 4.3 = 5.16\)</span>. - Exponentiation: <span class="math inline">\(4.3^2 = 18.49\)</span>. - Remainder (or Modulo): <span class="math inline">\(4.3 \text{ mod } 1.2 = 0.7\)</span>. - Integer Division: <span class="math inline">\(4.3 \ // \ 1.2 = 3.0\)</span>. - Division: <span class="math inline">\(4.3 \div 1.2\)</span>.</p>
<p>I’ll print these out in python to verify the answers are correct.</p>
<div class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2</span> <span class="op">+</span> <span class="fl">4.3</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2</span> <span class="op">-</span> <span class="fl">4.3</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fl">1.2</span> <span class="op">*</span> <span class="fl">4.3</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="fl">4.3</span> <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fl">4.3</span> <span class="op">%</span> <span class="fl">1.2</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="fl">4.3</span> <span class="op">//</span> <span class="fl">1.2</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="fl">4.3</span> <span class="op">/</span> <span class="fl">1.2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>5.5</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>-3.0999999999999996</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>5.159999999999999</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>18.49</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>0.7</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>3.0</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="15">
<pre><code>3.5833333333333335</code></pre>
</div>
</div>
<p>Most of them look right. But what the heck is going on with <span class="math inline">\(1.2 - 4.3\)</span> and <span class="math inline">\(1.2 \times 4.3\)</span>? We’re getting some weird trailing nines that shouldn’t be there. This gets to how floats are actually represented on a computer.</p>
</section>
<section id="representing-floats" class="level2">
<h2 class="anchored" data-anchor-id="representing-floats">Representing Floats</h2>
<p>Representing real numbers on a computer is a lot more subtle than representing integers. Since a computer can only have a finite number of bits, they can’t represent infinitely many digits, e.g.&nbsp;in irrational numbers like <span class="math inline">\(\pi\)</span>. Using finite word sizes will necessarily have to truncate real numbers to some number of decimal places. This truncation will create an error in the calculation called <strong>numerical roundoff</strong>.</p>
<p>So how should we represent a decimal number using <span class="math inline">\(n\)</span> bits? As an example, let’s imagine we’re trying to represent the number <span class="math inline">\(x=157.208\)</span>. Perhaps the first thing you might think of is to use some number of those bits to represent the integer part, and some number to represent the fractional part. Suppose you have <span class="math inline">\(n=16\)</span> bits available to represent <span class="math inline">\(x\)</span>. Then maybe you can use 8 bits for the integer part <span class="math inline">\(157\)</span>, and 8 bits for the fractional part <span class="math inline">\(0.208\)</span>. Converting both halves to binary, you’d get <span class="math display">\[157 \equiv 10011101, \quad 0.208 \equiv 0011010100111111.\]</span></p>
<p>Truncating both sequences to 8 bits (from the left), you could thus adopt a convention that <span class="math inline">\(157.208 \equiv 10011101 \ 00110101\)</span>.</p>
<p>This system is an example of a <strong>fixed point</strong> representation. This has to do with the fact that we’re always using a fixed number of bits for the integer part, and a fixed number for the fractional part. The decimal point isn’t allowed to <strong>float</strong>, or move around to allocate more bits to the integer or fractional part depending which needs more precision. The decimal point is <strong>fixed</strong>.</p>
<p>As I’ve suggested, the fixed point representation seems to be limited and not terribly useful. If you need really high precision in the fractional part, your only option is to use a larger word size. If you’re dealing with really big numbers and don’t care much about the fractional part, you also need a larger word size so you don’t run out of numbers. A solution to this problem is to allow the decimal point to float. We won’t allocate a fixed number of bits to represent the integer or fractional parts. We’ll design it in such a way that larger numbers give the integer part more bits, and smaller numbers give the fractional part more bits.</p>
<p>The trick to allowing the decimal point to float is to represent not just the digits of a number but also its exponent. Think about scientific notation, where if you have a number like say <span class="math inline">\(x=1015.23\)</span>, you can write it as <span class="math inline">\(1.01523 \cdot 10^3\)</span>, or <code>1.01523e3</code>. That <span class="math inline">\(3\)</span> is the exponent. It says something about how big the number is. What we can do is convert a number to scientific notation. Then use some number of bits to represent the exponent <span class="math inline">\(3\)</span> and some to represent the remaining part <span class="math inline">\(1.01523\)</span>. This is essentially the whole idea behind floating point.</p>
<p>In floating point representation, instead of using scientific notation with powers of ten, it’s more typical to use powers of two. When using powers of two, the decimal part can always be scaled to be between 1 and 2, so they look like <span class="math inline">\(1.567\)</span> or something like that. Since the <span class="math inline">\(1.\)</span> part is always there, we can agree it’s always there, and only worry about representing the fractional part <span class="math inline">\(0.567\)</span>. We’ll call this term the <strong>mantissa</strong>. Denoting the sign bit as <span class="math inline">\(s\)</span>, the exponent as <span class="math inline">\(e\)</span>, and the mantissa as <span class="math inline">\(m\)</span>, we can thus right any decimal number <span class="math inline">\(x\)</span> in a modified scientific notation of the form <span class="math display">\[x = (-1)^s \cdot (1+m) \cdot 2^{e}.\]</span> Once we’ve converted <span class="math inline">\(x\)</span> to this form, all we need to do is to figure out how to represent <span class="math inline">\(s\)</span>, <span class="math inline">\(m\)</span>, and <span class="math inline">\(e\)</span> using some number of bits of <span class="math inline">\(n\)</span>, called the floating point <strong>precision</strong>. Assume the <span class="math inline">\(n\)</span> bits of precision allocate <span class="math inline">\(1\)</span> bit for the sign, <span class="math inline">\(n_e\)</span> bits for the exponent, and <span class="math inline">\(n_m\)</span> bits for the mantissa, so <span class="math inline">\(n=1+n_e+n_m\)</span>.</p>
<p>Here are the steps to convert a number <span class="math inline">\(x\)</span> into its <span class="math inline">\(n\)</span>-bit floating point representation. - Given some number <span class="math inline">\(x\)</span>, get its modified scientific notation form <span class="math inline">\(x = (-1)^s \cdot (1+m) \cdot 2^e\)</span>. - Determine the sign of <span class="math inline">\(x\)</span>. If negative, set the sign bit to <span class="math inline">\(s=1\)</span>, else default to <span class="math inline">\(s=0\)</span>. Set <span class="math inline">\(x = |x|\)</span>. - Keep performing the operation <span class="math inline">\(x = x \ // \ 2\)</span> until <span class="math inline">\(1 \leq x \leq 2\)</span>. Keep track of the number of times you’re dividing, which is the <strong>exponent</strong> <span class="math inline">\(e\)</span>. - The remaining part will be some <span class="math inline">\(1 \leq x \leq 2\)</span>. Write it in the form <span class="math inline">\(x = 1 + m\)</span>, where <span class="math inline">\(m\)</span> is the mantissa. - Convert the scientific notation form into a sequence of <span class="math inline">\(n\)</span> bits, truncating where necessary. - For reasons I’ll describe in a second, it’s good to add a <strong>bias</strong> term <span class="math inline">\(b\)</span> to the exponent <span class="math inline">\(e\)</span> before converting the exponent to binary. Let <span class="math inline">\(e'=e+b\)</span> be this modified exponent. - Convert each of <span class="math inline">\(e'\)</span> and <span class="math inline">\(m\)</span> into binary sequences, truncated to sizes <span class="math inline">\(n_e\)</span>, and <span class="math inline">\(n_m\)</span> respectively. - Concatenate these binary sequences together to get a sequence of <span class="math inline">\(n=1+n_e+n_m\)</span> total bits. By convention, assume the order of bit concatenation is the sign bit, then exponent bits, then the mantissa bits.</p>
<p>There are of course other ways you could do it, for example by storing the sequences in a different order. I’m just stating one common way it’s done.</p>
<p>Since all of this must seem like Greek, here’s a quick example. Let’s consider the number <span class="math inline">\(x=15.25\)</span>. We’ll represent it using <span class="math inline">\(n=8\)</span> bits of precision, where <span class="math inline">\(n_e=4\)</span> is the number of exponent bits, <span class="math inline">\(n_m=3\)</span> is the number of precision bits, and <span class="math inline">\(b=10\)</span> is the bias. - Convert <span class="math inline">\(x=15.25\)</span> to its modified scientific notation. - Since <span class="math inline">\(x \geq 0\)</span> the sign is positive, so <span class="math inline">\(s=0\)</span>. - Keep integer dividing <span class="math inline">\(x\)</span> by <span class="math inline">\(2\)</span> until it’s less than <span class="math inline">\(2\)</span>. It takes <span class="math inline">\(e=3\)</span> divisions before <span class="math inline">\(x&lt;2\)</span>. - We now have <span class="math inline">\(x = 1.90625 \cdot 2^3\)</span>. The mantissa is then <span class="math inline">\(m = (1.90625-1) = 0.90625\)</span>. - In modified scientific notation form we now have <span class="math inline">\(x=(-1)^0 \cdot (1 + 0.90625) \cdot 2^3\)</span>. - Convert everything to binary. - Adding the bias to the exponent gives <span class="math inline">\(e'=3+10=13\)</span>. - Converting each piece to binary we get <span class="math inline">\(e' = 13 \equiv 1101\)</span>, <span class="math inline">\(m = 0.90625 \equiv 11101\)</span>. - Since <span class="math inline">\(m\)</span> requires more than <span class="math inline">\(n_m=3\)</span> bits to represent, truncate off the two right bits to get <span class="math inline">\(m \equiv 111\)</span>. - This truncation will cause numerical roundoff, since <span class="math inline">\(0.90625\)</span> truncates to <span class="math inline">\(0.875\)</span>. That’s an error of <span class="math inline">\(0.03125\)</span> that gets permanently lost. - The final representation is thus <span class="math inline">\(x \equiv 0 \ 1101 \ 111\)</span>.</p>
<p>So you can experiment, I wrote a helper function <code>represent_as_float</code> that lets you visualize this for different values of <span class="math inline">\(x\)</span>. Below I show the example I just calculated. I print out both the scientific notation form and its binary representation.</p>
<div class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>represent_as_float(<span class="fl">15.25</span>, n<span class="op">=</span><span class="dv">8</span>, n_exp<span class="op">=</span><span class="dv">4</span>, n_man<span class="op">=</span><span class="dv">3</span>, bias<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>scientific notation: (-1)^0 * (1 + 0.90625) * 2^3
8-bit floating point representation: 0 1101 111</code></pre>
</div>
</div>
<p>So what’s going on with the bias term <span class="math inline">\(b\)</span>? Why do we need it? The easiest answer to give is that without it, we can’t have negative exponents without having to use another sign bit for them. Consider a number like <span class="math inline">\(x=0.5\)</span>. In modified scientific notation this would look like <span class="math inline">\(x=(-1)^0 \cdot (1+0) \cdot 2^{-1} = 2^{-1}\)</span>, meaning its exponent would be <span class="math inline">\(e=-1\)</span>. Rather than have to keep yet another sign bit for the exponent, it’s easier to just add a bias term <span class="math inline">\(b\)</span> that ensures the exponent <span class="math inline">\(e'=e+b\)</span> is always non-negative. The higher the bias, the more precision we can show in the range <span class="math inline">\(-1 &lt; x &lt; 1\)</span>. The trade-off is that we lose precision for large values of <span class="math inline">\(x\)</span>.</p>
<p>On top of floats defined the way I mentioned, we also have some special numbers that get defined in a floating point system. These are <span class="math inline">\(\pm 0\)</span>, <span class="math inline">\(\pm \infty\)</span>, and <span class="math inline">\(\text{NaN}\)</span> or “not a number”. Each of these numbers is allocated its own special sequence of bits, depending on the precision. - <span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>: These numbers are typically represented using a biased exponent <span class="math inline">\(e'=0\)</span> (all zero bits) and a mantissa <span class="math inline">\(m=0\)</span> (all zero bits). The sign bit is used to distinguish between <span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>. In our example, these would be <span class="math inline">\(+0 \equiv 0 \ 0000 \ 000\)</span> and <span class="math inline">\(-0 \equiv 1 \ 0000 \ 000\)</span>. - <span class="math inline">\(+\infty\)</span> and <span class="math inline">\(-\infty\)</span>: These numbers are typically represented using the max allowed exponent (all one bits) and a mantissa <span class="math inline">\(m=0\)</span> (all zero bits). The sign bit is used to distinguish between <span class="math inline">\(+\infty\)</span> and <span class="math inline">\(-\infty\)</span>. In our example, these would be <span class="math inline">\(+\infty \equiv 0 \ 1111 \ 000\)</span> and <span class="math inline">\(-\infty \equiv 1 \ 1111 \ 000\)</span>. - <span class="math inline">\(\text{NaN}\)</span>: This value is typically represented using the max allowed exponent (all one bits) and a non-zero <span class="math inline">\(m \neq 0\)</span>. The sign bit is usually not used for <span class="math inline">\(\text{NaN}\)</span> values. Note this means we can have many different sequences that all represent <span class="math inline">\(\text{NaN}\)</span>. In our example, any number of the form <span class="math inline">\(\text{NaN} \equiv \text{x} \ 1111 \ \text{xxx}\)</span> would work.</p>
<p>So I can illustrate some points about how floating point numbers behave, I’m going to generate <em>all possible</em> <span class="math inline">\(8\)</span>-bit floats (excluding the special numbers) and plot them on a number line, similar to what I did above with the <span class="math inline">\(8\)</span>-bit signed integers. I’ll generate the floats using the using the helper function <code>gen_all_floats</code>, passing in the number of mantissa bits <code>n_man=3</code>, the number of exponent bits <code>n_exp=4</code>, and a bias of <code>bias=10</code>.</p>
<p>First, I’ll use these numbers to print out some interesting statistics of this 8-bit floating point system.</p>
<div class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>eight_bit_floats <span class="op">=</span> gen_all_floats(n<span class="op">=</span><span class="dv">8</span>, n_man<span class="op">=</span><span class="dv">3</span>, n_exp<span class="op">=</span><span class="dv">4</span>, bias<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Total number of 8-bit floats: </span><span class="sc">{</span><span class="bu">len</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Most negative float: </span><span class="sc">{</span><span class="bu">min</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Most positive float: </span><span class="sc">{</span><span class="bu">max</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Smallest nonzero float: </span><span class="sc">{</span><span class="bu">min</span>([x <span class="cf">for</span> x <span class="kw">in</span> eight_bit_floats <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>])<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Machine Epsilon: </span><span class="sc">{</span><span class="bu">min</span>([x <span class="cf">for</span> x <span class="kw">in</span> eight_bit_floats <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">1</span>]) <span class="op">-</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Total number of 8-bit floats: 120
Most negative float: -56.0
Most positive float: 56.0
Smallest nonzero float: 0.001953125
Machine Epsilon: 0.25</code></pre>
</div>
</div>
<p>We can see that this 8-bit system only contains 120 unique floats. We could practically list them all out. Just like with the integers, we see there’s a most negative float, <span class="math inline">\(-56.0\)</span>, and a most positive float, <span class="math inline">\(56.0\)</span>. The smallest float, i.e.&nbsp;the one closest to <span class="math inline">\(0\)</span>, is <span class="math inline">\(0.001953125\)</span>. Notice how much more precision the smallest float has than the largest ones do. The largest ones are basically whole numbers, while the smallest one has nine digits of precision. Evidently, floating point representations give much higher precision to numbers close to zero than to numbers far away from zero.</p>
<p>What happens if you try to input a float larger than the max, in this case <span class="math inline">\(56.0\)</span>? Typically it will <strong>overflow</strong>. This will result in either the system raising an error, or the number getting set to <span class="math inline">\(+\infty\)</span>, in a sense getting “rounded up”. Similarly, for numbers more negative than the min, in this case <span class="math inline">\(-56.0\)</span>, either an overflow error will be raised, or the number will get “rounded down” to <span class="math inline">\(-\infty\)</span>.</p>
<p>You have to be careful in overflow situations like this, especially when you don’t know for sure which of these your particular system will do. It’s amusing to note that python will raise an overflow error, but numpy will round to <span class="math inline">\(\pm \infty\)</span>. Two different conventions to worry about. Just as amusing, when dealing with signed integers, it’s numpy that will raise an error if you overflow, while python won’t care. One of those things…</p>
<p>What happens when you try to input a float smaller than the smallest value, in this case <span class="math inline">\(0.001953125\)</span>? In this case, the number is said to <strong>undeflow</strong>. Usually underflow won’t raise an error. The number will pretty much always just get set to <span class="math inline">\(+0\)</span> (or <span class="math inline">\(-0\)</span>). This is again something you have to worry about, especially if you’re dealing with small numbers in denominators, where they can lead to division by zero errors which <em>do</em> get raised.</p>
<p>Overflow and underflow errors are some of the most common numerical bugs that occur in deep learning, and usually result from not handling floats correctly to begin with.</p>
<p>I also printed out a special value called the <strong>machine epsilon</strong>. The machine epsilon, denoted <span class="math inline">\(\varepsilon_m\)</span>, is defined as the smallest value in a floating point system that’s larger than <span class="math inline">\(1\)</span>. In some sense, <span class="math inline">\(\varepsilon_m\)</span> is a proxy for how finely you can represent numbers in a given <span class="math inline">\(n\)</span>-bit floating point system. The smaller <span class="math inline">\(\varepsilon_m\)</span> the more precisely you can represent numbers, i.e.&nbsp;the more decimal places of precision you get access to. In our case, we get <span class="math inline">\(\varepsilon_m=0.25\)</span>. This means numbers in 8-bit floating point tend to be <span class="math inline">\(0.25\)</span> apart from each other on average, which means we can represent numbers in this system only with a measly 2-3 digits of precision.</p>
<p>With these numbers in hand let’s now plot their distribution on the number line. I’ll use the helper function <code>plot_number_dist</code> function to do this. Compare with the plot of the signed integers I did above.</p>
<div class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>plot_number_dist(eight_bit_floats, title<span class="op">=</span><span class="st">'Distribution of 8-bit Floats'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<p><img src="numerical-computing_files/figure-html/cell-19-output-1.png" class="img-fluid"></p>
</div>
</div>
<p>Notice how different this plot is from the ones for the signed integers. With the integers, the points were equally spaced. Now points close to <span class="math inline">\(0\)</span> are getting represented much closer together than points far from <span class="math inline">\(0\)</span>. There are <span class="math inline">\(74\)</span> of the <span class="math inline">\(120\)</span> total points showing up just in the range <span class="math inline">\([-1,1]\)</span>. That’s over half!. Meanwhile, only <span class="math inline">\(22\)</span> points total show up in the combined ranges of <span class="math inline">\([-60,-10]\)</span> and <span class="math inline">\([10,60]\)</span>. Very strange.</p>
<p>Feel free to play around with different floating point systems by using different choices for <code>n</code>, <code>n_man</code>, <code>n_exp</code>, and <code>bias</code>. Be careful, however, not to make <code>n_exp</code> too large or you may crash the kernel…</p>
</section>
<section id="double-precision" class="level2">
<h2 class="anchored" data-anchor-id="double-precision">Double Precision</h2>
<p>So how does python represent floats? Python by default uses what’s called <strong>double precision</strong> to represent floats, also called <strong>float64</strong>. This means <span class="math inline">\(n=64\)</span> total bits of precision are used, with <span class="math inline">\(n_e=11\)</span>, <span class="math inline">\(n_m=52\)</span>, and bias <span class="math inline">\(b=1023=2^{10}-1\)</span>. Double precision allows for a <em>much</em> larger range of numbers than 8-bit precision does: - The max value allowed is <span class="math inline">\(2^{2^{n_e}-b} = 2^{1025} \approx 10^{308}\)</span>. - The min value allowed is <span class="math inline">\(-2^{2^{n_e}-b} = -2^{1025} \approx -10^{308}\)</span>. - Numbers <em>outside</em> the range of about <span class="math inline">\([-10^{308}, 10^{308}]\)</span> will <em>overflow</em>. - The smallest values allowed are (plus or minus) <span class="math inline">\(2^{-b+1} = 2^{-1022} \approx 10^{-308}\)</span>. - Using subordinal numbers, the smallest values are (plus or minus) <span class="math inline">\(2^{-b-n_m+1} = 2^{-1074} \approx 10^{-324}\)</span>. - Numbers <em>inside</em> the range of about <span class="math inline">\([-10^{-308}, 10^{-308}]\)</span> will <em>underflow</em>. - Using subordinal numbers, this range is around <span class="math inline">\([-10^{-324}, 10^{-324}]\)</span>. - The machine epsilon is <span class="math inline">\(\varepsilon_m = 2^{-53} \approx 10^{-16}\)</span>. - Numbers requiring more than about 15-16 digits of precision will get truncated, resulting in numerical roundoff. - The special numbers <span class="math inline">\(\pm \infty\)</span>, <span class="math inline">\(\pm 0\)</span>, and <span class="math inline">\(\text{NaN}\)</span> are represented similarly as before, except using 64 bits.</p>
<p>To illustrate the point regarding numerical roundoff, here’s what happens if we try to use double precision floating point to define the constant <span class="math inline">\(\pi\)</span> to its first <a href="https://www.wolframalpha.com/input?i=pi+to+100+digits">100 digits</a>? Notice it just gets truncated to its first 15 digits. Double precision is unable to keep track of the other 85 digits. They just get lost to numerical roundoff.</p>
<div class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> <span class="fl">3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>pi</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>3.141592653589793</code></pre>
</div>
</div>
<p>Another thing to worry about is adding small numbers to medium to large sized numbers, e.g.&nbsp;<span class="math inline">\(10 + 10^{-16}\)</span>, which will just get rounded down to <span class="math inline">\(10.0\)</span>.</p>
<div class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fl">10.0</span> <span class="op">+</span> <span class="fl">1e-16</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="20">
<pre><code>10.0</code></pre>
</div>
</div>
<p>Numerical roundoff is often an issue when subtracting two floats. Here’s what happens when we try to subtract two numbers that should be equal, <span class="math inline">\(x=0.1+0.2\)</span> and <span class="math inline">\(y=0.3\)</span>. Instead of <span class="math inline">\(y-x=0\)</span>, we get <span class="math inline">\(y-x \approx -5.55 \cdot 10^{-17}\)</span>. The problem comes from the calculation <span class="math inline">\(x=0.1+0.2\)</span>, which caused a slight loss of precision in <span class="math inline">\(x\)</span>.</p>
<div class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">-</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="21">
<pre><code>-5.551115123125783e-17</code></pre>
</div>
</div>
<p>A major implication of these calculations is that you should <em>never</em> test floating points for exact equality because numerical roundoff can mess it up. If you’d tried to test something like <code>(y - x) == 0.0</code>, you’d have gotten the wrong answer. Instead, you want to test that <code>y - x</code> is less than some small number <code>tol</code>, called a <em>tolerance</em>, i.e.&nbsp;<code>abs(y - x) &lt; tol</code>.</p>
<div class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>y <span class="op">-</span> x <span class="op">==</span> <span class="fl">0.0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="22">
<pre><code>False</code></pre>
</div>
</div>
<div class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-5</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="bu">abs</span>(y <span class="op">-</span> x) <span class="op">&lt;</span> tol</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="23">
<pre><code>True</code></pre>
</div>
</div>
<p>Numerical roundoff explains why we got the weird results above when subtracting <span class="math inline">\(1.2 - 4.3\)</span>. The imperfect precision in the two numbers resulted in a numerical roundoff error, leading in the trailing <span class="math inline">\(9\)</span>s that should’ve rounded up to <span class="math inline">\(-3.1\)</span> exactly. In general, subtracting floats is one of the most dangerous operations to do, as it tends to lead to the highest loss of precision in calculations. The closer two numbers are to being equal the worse this loss of precision tends to get.</p>
<p>I mentioned that double precision has a smallest number of <span class="math inline">\(2^{-1022} \approx 10^{-308}\)</span>, but caveated that by saying that, by using a trick called <strong>subordinal numbers</strong>, we can get the smallest number down to about <span class="math inline">\(10^{-324}\)</span>. What did I mean by this? It turns out that the bits where the biased exponent <span class="math inline">\(e'=0\)</span> (i.e.&nbsp;all exponent bits are zero) go mostly unused in the standard version of double precision. By using this zero exponent and allowing the mantissa <span class="math inline">\(m\)</span> to take on all its possible values, we can get about <span class="math inline">\(2^{52}\)</span> more values (since the mantissa has 52 bits). This lets us get all the way down to <span class="math inline">\(2^{-1022} \cdot 2^{-52} = 2^{-1074} \approx 10^{-324}\)</span>.</p>
<p>Python (and numpy) by default implements double precision with subordinal numbers, as we can see.</p>
<div class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">**</span> (<span class="op">-</span><span class="dv">1074</span>)</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="op">**</span> (<span class="op">-</span><span class="dv">1075</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>5e-324</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="24">
<pre><code>0.0</code></pre>
</div>
</div>
<p>The special numbers <span class="math inline">\(\pm \infty\)</span>, <span class="math inline">\(\pm 0\)</span>, and <span class="math inline">\(\text{NaN}\)</span> are also defined in double precision. In python (and numpy) they’re given by the following commands, - <span class="math inline">\(\infty\)</span>: <code>float('inf')</code> or <code>np.inf</code>, - <span class="math inline">\(-\infty\)</span>: <code>float('-inf')</code> or <code>-np.inf</code>, - <span class="math inline">\(\pm 0\)</span>: <code>0</code>, - <span class="math inline">\(\text{NaN}\)</span>: <code>float('nan')</code> or <code>np.nan</code>.</p>
<div class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="bu">float</span>(<span class="st">'inf'</span>)</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>np.inf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>inf</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="25">
<pre><code>inf</code></pre>
</div>
</div>
<div class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span>np.inf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>-inf</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="26">
<pre><code>-inf</code></pre>
</div>
</div>
<div class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span><span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>0</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="27">
<pre><code>0</code></pre>
</div>
</div>
<div class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="bu">float</span>(<span class="st">'nan'</span>)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>np.nan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>nan</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="28">
<pre><code>nan</code></pre>
</div>
</div>
<p>You may be curious what exactly <span class="math inline">\(\text{NaN}\)</span> (“not a number”) is and where it might show up. Basically, NaNs are used wherever values are undefined. Anytime an operation doesn’t return a sensible value it risks getting converted to NaN. One example is the operation <span class="math inline">\(\infty - \infty = \infty + (-\infty)\)</span>, which mathematically doesn’t make sense. No, it’s not zero…</p>
<div class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="bu">float</span>(<span class="st">'inf'</span>) <span class="op">+</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>np.inf <span class="op">-</span> np.inf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>nan</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="29">
<pre><code>nan</code></pre>
</div>
</div>
<p>I’ll finish this section by mentioning that there are two other floating point representations worth being aware of: <strong>single precision</strong> (or <strong>float32</strong>), and <strong>half precision</strong> (or <strong>float16</strong>). Single precision uses 32 bits to represent a floating point number. Half precision uses 16 bits. It may seem strange to even bother having these less-precise precisions lying around, but they do have their uses. For example, half precision shows up in deep learning as a more efficient way to represent the weights of a neural network. Since half precision floats only take up 25% as many bits as default double precision floats do, using them can yield a 4x reduction in model memory sizes. We’ll see more on this later.</p>
</section>
<section id="common-floating-point-pitfalls" class="level2">
<h2 class="anchored" data-anchor-id="common-floating-point-pitfalls">Common Floating Point Pitfalls</h2>
<p>To cap this long section on floats, here’s a list of common pitfalls people run into when working with floating point numbers, and some ways to avoid each one. This is probably the most important thing to take away from this section. You may find it helpful to reference later on. See this <a href="https://www.codeproject.com/Articles/29637/Five-Tips-for-Floating-Point-Programming">post</a> for more information.</p>
<ol type="1">
<li>Numerical overflow: Letting a number blow up to infinity (or negative infinity)
<ul>
<li>Clip numbers from above to keep them from being too large</li>
<li>Work with the log of the number instead</li>
<li>Make sure you’re not dividing by zero or a really small number</li>
<li>Normalize numbers so they’re all on the same scale</li>
</ul></li>
<li>Numerical underflow: Letting a number spiral down to zero
<ul>
<li>Clip numbers from below to keep them from being too small</li>
<li>Work with the exp of the number instead</li>
<li>Normalize numbers so they’re all on the same scale</li>
</ul></li>
<li>Subtracting floats: Avoid subtracting two numbers that are approximately equal
<ul>
<li>Reorder operations so approximately equal numbers aren’t nearby to each other</li>
<li>Use some algebraic manipulation to recast the problem into a different form</li>
<li>Avoid differencing squares (e.g.&nbsp;when calculating the standard deviation)</li>
</ul></li>
<li>Testing for equality: Trying to test exact equality of two floats
<ul>
<li>Instead of testing <code>x == y</code>, test for approximate equality with something like <code>abs(x - y) &lt;= tol</code></li>
<li>Use functions like <code>np.allclose(x, y)</code>, which will do this for you</li>
</ul></li>
<li>Unstable functions: Defining some functions in the naive way instead of in a stable way
<ul>
<li>Examples: factorials, softmax, logsumexp</li>
<li>Use a more stable library implementation of these functions</li>
<li>Look for the same function but in log form, e.g.&nbsp;<code>log_factorial</code> or <code>log_softmax</code></li>
</ul></li>
<li>Beware of NaNs: Once a number becomes NaN it’ll always be a NaN from then on
<ul>
<li>Prevent underflow and overflow</li>
<li>Remove missing values or replace them with finite values</li>
</ul></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-body">
  <div class="nav-page nav-page-previous">
      <a href="../notebooks/basic-math.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Basic Math</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../notebooks/vectorization.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Arrays and Vectorization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>