<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.335">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Mathematics and Computer Science for Machine Learning - 3&nbsp; Numerical Computation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../notebooks/calculus.html" rel="next">
<link href="../notebooks/basic-math.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Numerical Computation</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Mathematics and Computer Science for Machine Learning</a> 
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/algorithms.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Programming and Algorithms</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/basic-math.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Basic Math</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/numerical-computing.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Numerical Computation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/calculus.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/linear-systems.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Linear Systems</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/vectors.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Vector Spaces</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/matrices.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Matrix Algebra</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/tensors.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">Tensor Algebra</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/multivariate-calculus.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">Multivariate Calculus</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/optimization.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">Optimization</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/probability.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">Basic Probability</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/multivariate-probability.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">Multivariate Distributions</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../notebooks/statistics.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">Statistics</span></a>
  </div>
</li>
    </ul>
    </div>
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#integers" id="toc-integers" class="nav-link active" data-scroll-target="#integers"><span class="toc-section-number">3.1</span>  Integers</a>
  <ul class="collapse">
  <li><a href="#basics" id="toc-basics" class="nav-link" data-scroll-target="#basics"><span class="toc-section-number">3.1.1</span>  Basics</a></li>
  <li><a href="#representing-integers" id="toc-representing-integers" class="nav-link" data-scroll-target="#representing-integers"><span class="toc-section-number">3.1.2</span>  Representing Integers</a></li>
  </ul></li>
  <li><a href="#floats" id="toc-floats" class="nav-link" data-scroll-target="#floats"><span class="toc-section-number">3.2</span>  Floats</a>
  <ul class="collapse">
  <li><a href="#basics-1" id="toc-basics-1" class="nav-link" data-scroll-target="#basics-1"><span class="toc-section-number">3.2.1</span>  Basics</a></li>
  <li><a href="#representing-floats" id="toc-representing-floats" class="nav-link" data-scroll-target="#representing-floats"><span class="toc-section-number">3.2.2</span>  Representing Floats</a></li>
  <li><a href="#double-precision" id="toc-double-precision" class="nav-link" data-scroll-target="#double-precision"><span class="toc-section-number">3.2.3</span>  Double Precision</a></li>
  <li><a href="#common-floating-point-pitfalls" id="toc-common-floating-point-pitfalls" class="nav-link" data-scroll-target="#common-floating-point-pitfalls"><span class="toc-section-number">3.2.4</span>  Common Floating Point Pitfalls</a></li>
  </ul></li>
  <li><a href="#array-computing" id="toc-array-computing" class="nav-link" data-scroll-target="#array-computing"><span class="toc-section-number">3.3</span>  Array Computing</a>
  <ul class="collapse">
  <li><a href="#higher-dimensional-arrays" id="toc-higher-dimensional-arrays" class="nav-link" data-scroll-target="#higher-dimensional-arrays"><span class="toc-section-number">3.3.1</span>  Higher-Dimensional Arrays</a></li>
  </ul></li>
  <li><a href="#broadcasting" id="toc-broadcasting" class="nav-link" data-scroll-target="#broadcasting"><span class="toc-section-number">3.4</span>  Broadcasting</a>
  <ul class="collapse">
  <li><a href="#motivation" id="toc-motivation" class="nav-link" data-scroll-target="#motivation"><span class="toc-section-number">3.4.1</span>  Motivation</a></li>
  <li><a href="#broadcasting-rules" id="toc-broadcasting-rules" class="nav-link" data-scroll-target="#broadcasting-rules"><span class="toc-section-number">3.4.2</span>  Broadcasting Rules</a></li>
  </ul></li>
  <li><a href="#floating-point-operations" id="toc-floating-point-operations" class="nav-link" data-scroll-target="#floating-point-operations"><span class="toc-section-number">3.5</span>  Floating Point Operations</a></li>
  </ul>
</nav>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content column-page-right" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Numerical Computation</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In this lesson I’ll discuss the basics of numerical computation. This includes how numbers are represented on a computer, as well as the topics of arrays and vectorization, which is the use of efficient array operations to speed up computations.This may seem too basic to mention, but it’s actually very important. There’s a lot of subtlety involved. Let’s get started.</p>
<div class="cell" data-execution_count="1">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> utils.math_ml <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<section id="integers" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="integers"><span class="header-section-number">3.1</span> Integers</h2>
<section id="basics" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="basics"><span class="header-section-number">3.1.1</span> Basics</h3>
<p>Recall the <strong>integers</strong> are whole numbers that can be positive, negative, or zero. Examples are 5, 100151, 0, -72, etc. The set of all integers is commonly denoted by the symbol <span class="math inline">\(\mathbb{Z}\)</span>.</p>
<p>In python, integers (ints for short) are builtin objects of type <code>int</code> that more or less follow the rules that integers in math follow.</p>
<p>Among other things, the following operations can be performed with integers:</p>
<ul>
<li>Addition: <span class="math inline">\(2 + 2 = 4\)</span>.</li>
<li>Subtraction: <span class="math inline">\(2 - 5 = -3\)</span>.</li>
<li>Multiplication: <span class="math inline">\(3 \cdot 3 = 9\)</span>
<ul>
<li>In python this is the <code>*</code> operator, e.g.&nbsp;<code>3 * 3 = 9</code></li>
</ul></li>
<li>Exponentiation: <span class="math inline">\(2^3 = 2 \times 2 \times 2 = 8\)</span>
<ul>
<li>In python this is the <code>**</code> operator, e.g.&nbsp;<code>2 ** 3 = 8</code>.</li>
</ul></li>
<li>Remainder (or Modulo): the remainder of 10 when divided by 3 is 1, written <span class="math inline">\(10 \text{ mod } 3 = 1\)</span>
<ul>
<li>In python this is the <code>%</code> operator, e.g.&nbsp;<code>10 % 3 = 1</code>.</li>
</ul></li>
</ul>
<p>If any of these operations are applied to two integers, the output will itself always be an integer.</p>
<p>Here are a few examples.</p>
<div class="cell" data-execution_count="2">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'2 + 2 = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'2 - 5 = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">-</span> <span class="dv">5</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'3 * 3 = </span><span class="sc">{</span><span class="dv">3</span> <span class="op">*</span> <span class="dv">3</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'10 % 3 = </span><span class="sc">{</span><span class="dv">10</span> <span class="op">%</span> <span class="dv">3</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'2 ** 3 = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">**</span> <span class="dv">3</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>2 + 2 = 4
2 - 5 = -3
3 * 3 = 9
10 % 3 = 1
2 ** 3 = 8</code></pre>
</div>
</div>
<p>What about division? You can’t always divide two integers and get another integer. What you have to do instead is called integer division. Here you divide the two numbers and then round the answer down to the nearest whole number. Since <span class="math inline">\(5 \div 2 = 2.5\)</span>, the nearest rounded down integer is 2.</p>
<p>In math, this “nearest rounded down integer” 2 is usually called the <strong>floor</strong> of 2.5, and represented with the funny symbol <span class="math inline">\(\lfloor 2.5 \rfloor.\)</span> Using this notation we can write the above integer division as <span class="math display">\[\big\lfloor \frac{5}{2} \big\rfloor = 2.\]</span></p>
<p>In python, integer division is done using the <code>//</code> operator, e.g.&nbsp;<code>5 // 2 = 2</code>. I’ll usually write <span class="math inline">\(5 \ // \ 2\)</span> instead of <span class="math inline">\(\big\lfloor \frac{5}{2} \big\rfloor\)</span> when it makes sense, <span class="math display">\[5 \ // \ 2 = \big\lfloor \frac{5}{2} \big\rfloor = 2.\]</span></p>
<div class="cell" data-execution_count="3">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'5 // 2 = </span><span class="sc">{</span><span class="dv">5</span> <span class="op">//</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>5 // 2 = 2</code></pre>
</div>
</div>
<p>We can also do regular division <code>/</code> with ints, but the output will <em>not</em> be an integer even if the answer should be, e.g.&nbsp;<code>4 / 2</code>. Only integer division is guaranteed to return an integer. I’ll get to this shortly.</p>
<div class="cell" data-execution_count="4">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'4 / 2 = </span><span class="sc">{</span><span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'type(4 / 2) = </span><span class="sc">{</span><span class="bu">type</span>(<span class="dv">4</span> <span class="op">/</span> <span class="dv">2</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>4 / 2 = 2.0
type(4 / 2) = &lt;class 'float'&gt;</code></pre>
</div>
</div>
<div class="cell" data-execution_count="5">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'4 // 2 = </span><span class="sc">{</span><span class="dv">4</span> <span class="op">//</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'type(4 // 2) = </span><span class="sc">{</span><span class="bu">type</span>(<span class="dv">4</span> <span class="op">//</span> <span class="dv">2</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>4 // 2 = 2
type(4 // 2) = &lt;class 'int'&gt;</code></pre>
</div>
</div>
<p>Division by zero is of course undefined for both division and integer division. In python it will always raise a <code>ZeroDivisionError</code> like so.</p>
<div class="cell" data-execution_count="6">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'4 / 0 = </span><span class="sc">{</span><span class="dv">4</span> <span class="op">/</span> <span class="dv">0</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-error">
<pre><code>ZeroDivisionError: division by zero</code></pre>
</div>
</div>
<div class="cell" data-execution_count="7">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'4 // 0 = </span><span class="sc">{</span><span class="dv">4</span> <span class="op">//</span> <span class="dv">0</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-error">
<pre><code>ZeroDivisionError: integer division or modulo by zero</code></pre>
</div>
</div>
</section>
<section id="representing-integers" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="representing-integers"><span class="header-section-number">3.1.2</span> Representing Integers</h3>
<p>Just like every other data type, on a computer integers are actually represented internally as a sequence of bits. A <strong>bit</strong> is a “binary digit”, 0 or 1. A sequence of bits is just a sequence of zeros and ones, e.g.&nbsp;0011001010 or 1001001.</p>
<p>The number of bits used to represent a piece of data is called its <strong>word size</strong>. If we use a word size of <span class="math inline">\(n\)</span> bits to represent an integer, then there are <span class="math inline">\(2^n\)</span> possible integer values we can represent.</p>
<p>If integers could only be positive or zero, representing them with bits would be easy. We could just convert them to binary and that’s it. To convert a non-negative integer to binary, we just need to keep dividing it by 2 and recording its remainder (0 or 1) at each step. The binary form is then just the sequence of remainders, written right to left. More generally, the binary sequence of some arbitrary number <span class="math inline">\(x\)</span> is the sequence of coefficients <span class="math inline">\(b_k=0,1\)</span> in the sum</p>
<p><span class="math display">\[x = \sum_{k=-\infty}^\infty b_k 2^k = \cdots + b_2 2^2 + b_1 2^1 + b_0 2^0 + b_{-1} 2^{-1} + b_{-2} 2^{-2} + \cdots.\]</span></p>
<p>Here’s an example. Suppose we wanted to represent the number <span class="math inline">\(12\)</span> in binary.</p>
<ol type="1">
<li><span class="math inline">\(12 \ // \ 2 = 6\)</span> with a remainder of <span class="math inline">\(0 = 12 \text{ mod } 2\)</span>, so the first bit from the right is then <span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(6 \ // \ 2 = 3\)</span> with a remainder of <span class="math inline">\(0 = 6 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(0\)</span>.</li>
<li><span class="math inline">\(3 \ // \ 2 = 1\)</span> with a remainder of <span class="math inline">\(1 = 3 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(1\)</span>.</li>
<li><span class="math inline">\(1 \ // \ 2 = 0\)</span> with a remainder of <span class="math inline">\(1 = 1 \text{ mod } 2\)</span>, so the next bit is <span class="math inline">\(1\)</span>.</li>
</ol>
<p>So the binary representation of <span class="math inline">\(12\)</span> is <span class="math inline">\(1100\)</span>, which is the sequence of coefficients in the sum</p>
<p><span class="math display">\[12 = 1 \cdot 2^{3} + 1 \cdot 2^{2} + 0 \cdot 2^{1} + 0 \cdot 2^{0}.\]</span></p>
<p>Rather than keep doing these by hand, you can quickly convert a number to binary in python by using <code>bin</code>. It’ll return a string representing the binary sequence of that number, prepended with the special prefix <code>0b</code>. To get back to the integer from, use <code>int</code>, passing in a base of <code>2</code>.</p>
<div class="cell" data-execution_count="8">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'bin(12) = </span><span class="sc">{</span><span class="bu">bin</span>(<span class="dv">12</span>)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"int('0b110', 2) = </span><span class="sc">{</span><span class="bu">int</span>(<span class="st">'0b110'</span>, <span class="dv">2</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>bin(12) = 0b1100
int('0b110', 2) = 6</code></pre>
</div>
</div>
<p>This representation works fine for non-negative integers, also called the <strong>unsigned integers</strong> in computer science. To represent an unsigned integer with <span class="math inline">\(n\)</span> bits, just get its binary form and prepend it with enough zeros on the left until all <span class="math inline">\(n\)</span> bits are used. For example, if we used 8-bit unsigned integers then <span class="math inline">\(n=8\)</span>, hence representing the number <span class="math inline">\(12\)</span> would look like <span class="math inline">\(00000110\)</span>. Simple, right?</p>
<p>Unsigned ints work fine if we never have to worry about negative numbers. But in general we do. These are called the <strong>signed integers</strong> in computer science. To represent signed ints, we need to use one of the bits to represent the sign. What we can do is reserve the left-most bit for the sign, <span class="math inline">\(0\)</span> if the integers is positive or zero, <span class="math inline">\(1\)</span> if the integer is negative.</p>
<p>For example, if we used 8-bit <em>signed</em> integers to represent <span class="math inline">\(12\)</span>, we’d again write <span class="math inline">\(00000110\)</span>, exactly as before. But this time it’s understood that left-most <span class="math inline">\(0\)</span> is encoding the fact that <span class="math inline">\(12\)</span> is positive. If instead we wanted to represent the number <span class="math inline">\(-12\)</span> we’d need to flip that bit to a <span class="math inline">\(1\)</span>, so we’d get <span class="math inline">\(10000110\)</span>.</p>
<p>Let’s now do an example of a simple integer system. Consider the system of 4-bit signed ints. In this simple system, <span class="math inline">\(n=4\)</span> is the word size, and an integer <span class="math inline">\(x\)</span> is represented with the sequence of bits</p>
<p><span class="math display">\[x \equiv sb_1b_2b_3,\]</span></p>
<p>where <span class="math inline">\(s\)</span> is the sign bit and <span class="math inline">\(b_1b_2b_3\)</span> are the remaining 3 bits allowed to represent the numerical digits. This system can represent <span class="math inline">\(2^4=16\)</span> possible values in the range <span class="math inline">\([-2^3+1,2^3-1] = [-8,7]\)</span>, given in the following table:</p>
<table class="table">
<thead>
<tr class="header">
<th>Integer</th>
<th>Representation</th>
<th>Integer</th>
<th>Representation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-0</td>
<td>1000</td>
<td>+0</td>
<td>0000</td>
</tr>
<tr class="even">
<td>-1</td>
<td>1001</td>
<td>1</td>
<td>0001</td>
</tr>
<tr class="odd">
<td>-2</td>
<td>1010</td>
<td>2</td>
<td>0010</td>
</tr>
<tr class="even">
<td>-3</td>
<td>1011</td>
<td>3</td>
<td>0011</td>
</tr>
<tr class="odd">
<td>-4</td>
<td>1100</td>
<td>4</td>
<td>0100</td>
</tr>
<tr class="even">
<td>-5</td>
<td>1101</td>
<td>5</td>
<td>0101</td>
</tr>
<tr class="odd">
<td>-6</td>
<td>1110</td>
<td>6</td>
<td>0110</td>
</tr>
<tr class="even">
<td>-7</td>
<td>1111</td>
<td>7</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p>Note the presence of <span class="math inline">\(-0 \equiv 1110\)</span> in the upper left. This is because the system as I’ve defined it leaves open the possibility of two zeros, <span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>, since for zero the sign bit is redundant. A way to get around this is to encode the negative numbers slightly differently, by not just setting the sign bit to one, but also inverting the remaining bits and subtracting one from them. This is called the <strong>two’s complement representation</strong>. It’s how most languages, including python, actually represent integers. I won’t go into this representation in any depth, except to say that it gets rid of the need for <span class="math inline">\(-0\)</span> and replaces it with <span class="math inline">\(-2^{n-1}\)</span>.</p>
<p>Here’s what that table looks like for 4-bit integers. It’s almost the same, except there’s no <span class="math inline">\(-0\)</span>, instead a <span class="math inline">\(-8\)</span>. Notice the positive integers look exactly the same. It’s only the negative integers that look different. For them, the right three bits get inverted and added with a one.</p>
<table class="table">
<thead>
<tr class="header">
<th>Integer</th>
<th>Two’s Complement</th>
<th>Integer</th>
<th>Two’s Complement</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>-1</td>
<td>1111</td>
<td>0</td>
<td>0000</td>
</tr>
<tr class="even">
<td>-2</td>
<td>1110</td>
<td>1</td>
<td>0001</td>
</tr>
<tr class="odd">
<td>-3</td>
<td>1101</td>
<td>2</td>
<td>0010</td>
</tr>
<tr class="even">
<td>-4</td>
<td>1100</td>
<td>3</td>
<td>0011</td>
</tr>
<tr class="odd">
<td>-5</td>
<td>1011</td>
<td>4</td>
<td>0100</td>
</tr>
<tr class="even">
<td>-6</td>
<td>1010</td>
<td>5</td>
<td>0101</td>
</tr>
<tr class="odd">
<td>-7</td>
<td>1001</td>
<td>6</td>
<td>0110</td>
</tr>
<tr class="even">
<td>-8</td>
<td>1000</td>
<td>7</td>
<td>0111</td>
</tr>
</tbody>
</table>
<p>It’s worth visualizing what integers look like on the number line, if for nothing else than to compare it with what floats look like later on. Below I’ll plot what a 6-bit signed integer system would look like. Such a system should go from -32 to 31. As you’d expect, we get a bunch of equally spaced points from -32 to 31.</p>
<div class="cell" data-execution_count="9">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>six_bit_ints <span class="op">=</span> <span class="bu">range</span>(<span class="op">-</span><span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>), <span class="dv">2</span><span class="op">**</span>(n<span class="op">-</span><span class="dv">1</span>))</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>plot_number_dist(six_bit_ints, title<span class="op">=</span><span class="ss">f'Distribution of </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">-bit Signed Ints'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="numerical-computing_files/figure-html/cell-10-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>In python, integers are represented by default using a much bigger word size of <span class="math inline">\(n=64\)</span> bits, called <strong>long</strong> integers, or <strong>int64</strong> for short. This means (using two’s complement) we can represent <span class="math inline">\(2^{64}=18446744073709551616\)</span> possible integer values in the range <span class="math inline">\([-2^{63}, 2^{63}-1]\)</span>.</p>
<p>You can see from this that 64-bit integers have a minimum integer allowed and a maximum integer allowed, which are</p>
<p><span class="math display">\[\text{min\_int}=-2^{63}=-9223372036854775808, \qquad \text{max\_int}=2^{63}-1=9223372036854775807.\]</span></p>
<p>What I’ve said is technically only exactly true in older versions of pythons as well as other programming languages like C. It turns out newer versions of python have a few added tricks that allow you to represent essentially arbitrarily large integers. You can see this by comparing it to numpy’s internal int64 representation, which uses the C version. A numpy int64 outside the valid range will throw an overflow error.</p>
<div class="cell" data-execution_count="10">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>min_int <span class="op">=</span> <span class="op">-</span><span class="dv">2</span> <span class="op">**</span> <span class="dv">63</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>max_int <span class="op">=</span> <span class="dv">2</span> <span class="op">**</span> <span class="dv">63</span> <span class="op">-</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="11">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'min_int - 1 = </span><span class="sc">{</span>min_int <span class="op">-</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'min_int = </span><span class="sc">{</span>np<span class="sc">.</span>int64(min_int <span class="op">-</span> <span class="dv">1</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>min_int - 1 = -9223372036854775809</code></pre>
</div>
<div class="cell-output cell-output-error">
<pre><code>OverflowError: Python int too large to convert to C long</code></pre>
</div>
</div>
<div class="cell" data-execution_count="12">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'max_int + 1 = </span><span class="sc">{</span>min_int <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'max_int = </span><span class="sc">{</span>np<span class="sc">.</span>int64(min_int <span class="op">+</span> <span class="dv">1</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>max_int + 1 = -9223372036854775807
max_int = -9223372036854775807</code></pre>
</div>
</div>
</section>
</section>
<section id="floats" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="floats"><span class="header-section-number">3.2</span> Floats</h2>
<section id="basics-1" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="basics-1"><span class="header-section-number">3.2.1</span> Basics</h3>
<p>What if we want to represent decimal numbers or fractions instead of whole numbers, like <span class="math inline">\(1.2\)</span> or <span class="math inline">\(0.99999\)</span>, or even irrational numbers like <span class="math inline">\(\pi=3.1415926\dots\)</span>? To do this we need a new system of numbers that I’ll call floating point numbers, or <strong>floats</strong>, for reasons I’ll explain soon. Floats will be a computer’s best attempt to represent the real numbers <span class="math inline">\(\mathbb{R}\)</span>. They’ll represent real numbers only approximately with some specified precision.</p>
<p>In python, floats are builtin objects of type <code>float</code>. Floats obey pretty much the same operations that integers do with some minor exceptions:</p>
<ul>
<li>Addition: <span class="math inline">\(1.2 + 4.3 = 5.5\)</span>.</li>
<li>Subtraction: <span class="math inline">\(1.2 - 4.3 = -3.1\)</span>.</li>
<li>Multiplication: <span class="math inline">\(1.2 \times 4.3 = 5.16\)</span>.</li>
<li>Exponentiation: <span class="math inline">\(4.3^2 = 18.49\)</span>.</li>
<li>Remainder (or Modulo): <span class="math inline">\(4.3 \text{ mod } 1.2 = 0.7\)</span>.</li>
<li>Integer Division: <span class="math inline">\(4.3 \ // \ 1.2 = 3.0\)</span>.</li>
<li>Division: <span class="math inline">\(4.3 \div 1.2\)</span>.</li>
</ul>
<p>Let’s verify the first few of these to see what’s going on.</p>
<div class="cell" data-execution_count="13">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'1.2 + 4.3 = </span><span class="sc">{</span><span class="fl">1.2</span> <span class="op">+</span> <span class="fl">4.3</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'1.2 - 4.3 = </span><span class="sc">{</span><span class="fl">1.2</span> <span class="op">-</span> <span class="fl">4.3</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'1.2 * 4.3 = </span><span class="sc">{</span><span class="fl">1.2</span> <span class="op">*</span> <span class="fl">4.3</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1.2 + 4.3 = 5.5
1.2 - 4.3 = -3.0999999999999996
1.2 * 4.3 = 5.159999999999999</code></pre>
</div>
</div>
<p>Most of them look right. But what the heck is going on with <span class="math inline">\(1.2 - 4.3\)</span> and <span class="math inline">\(1.2 \times 4.3\)</span>? We’re getting some weird trailing nines that shouldn’t be there. This gets to how floats are actually represented on a computer.</p>
</section>
<section id="representing-floats" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="representing-floats"><span class="header-section-number">3.2.2</span> Representing Floats</h3>
<p>Representing real numbers on a computer is a lot more subtle than representing integers. Since a computer can only have a finite number of bits, they can’t represent infinitely many digits, e.g.&nbsp;in irrational numbers like <span class="math inline">\(\pi\)</span>. Using finite word sizes will necessarily have to truncate real numbers to some number of decimal places. This truncation will create an error in the calculation called <strong>numerical roundoff</strong>.</p>
<p>So how should we represent a decimal number using <span class="math inline">\(n\)</span> bits? As an example, let’s imagine we’re trying to represent the number <span class="math inline">\(x=157.208\)</span>. Perhaps the first thing you might think of is to use some number of those bits to represent the integer part, and some number to represent the fractional part. Suppose you have <span class="math inline">\(n=16\)</span> bits available to represent <span class="math inline">\(x\)</span>. Then maybe you can use 8 bits for the integer part <span class="math inline">\(157\)</span>, and 8 bits for the fractional part <span class="math inline">\(0.208\)</span>. Converting both halves to binary, you’d get <span class="math display">\[157 \equiv 10011101, \quad 0.208 \equiv 0011010100111111.\]</span></p>
<p>Truncating both sequences to 8 bits (from the left), you could thus adopt a convention that <span class="math inline">\(157.208 \equiv 10011101 \ 00110101\)</span>.</p>
<p>This system is an example of a <strong>fixed point</strong> representation. This has to do with the fact that we’re always using a fixed number of bits for the integer part, and a fixed number for the fractional part. The decimal point isn’t allowed to <strong>float</strong>, or move around to allocate more bits to the integer or fractional part depending which needs more precision. The decimal point is <strong>fixed</strong>.</p>
<p>As I’ve suggested, the fixed point representation seems to be limited and not terribly useful. If you need really high precision in the fractional part, your only option is to use a larger word size. If you’re dealing with really big numbers and don’t care much about the fractional part, you also need a larger word size so you don’t run out of numbers. A solution to this problem is to allow the decimal point to float. We won’t allocate a fixed number of bits to represent the integer or fractional parts. We’ll design it in such a way that larger numbers give the integer part more bits, and smaller numbers give the fractional part more bits.</p>
<p>The trick to allowing the decimal point to float is to represent not just the digits of a number but also its exponent. Think about scientific notation, where if you have a number like say <span class="math inline">\(x=1015.23\)</span>, you can write it as <span class="math inline">\(1.01523 \cdot 10^3\)</span>, or <code>1.01523e3</code>. That <span class="math inline">\(3\)</span> is the exponent. It says something about how big the number is. What we can do is convert a number to scientific notation. Then use some number of bits to represent the exponent <span class="math inline">\(3\)</span> and some to represent the remaining part <span class="math inline">\(1.01523\)</span>. This is essentially the whole idea behind floating point.</p>
<p>In floating point representation, instead of using scientific notation with powers of ten, it’s more typical to use powers of two. When using powers of two, the decimal part can always be scaled to be between 1 and 2, so they look like <span class="math inline">\(1.567\)</span> or something like that. Since the <span class="math inline">\(1.\)</span> part is always there, we can agree it’s always there, and only worry about representing the fractional part <span class="math inline">\(0.567\)</span>. We’ll call this term the <strong>mantissa</strong>. Denoting the sign bit as <span class="math inline">\(s\)</span>, the exponent as <span class="math inline">\(e\)</span>, and the mantissa as <span class="math inline">\(m\)</span>, we can thus right any decimal number <span class="math inline">\(x\)</span> in a modified scientific notation of the form <span class="math display">\[x = (-1)^s \cdot (1+m) \cdot 2^{e}.\]</span> Once we’ve converted <span class="math inline">\(x\)</span> to this form, all we need to do is to figure out how to represent <span class="math inline">\(s\)</span>, <span class="math inline">\(m\)</span>, and <span class="math inline">\(e\)</span> using some number of bits of <span class="math inline">\(n\)</span>, called the floating point <strong>precision</strong>. Assume the <span class="math inline">\(n\)</span> bits of precision allocate <span class="math inline">\(1\)</span> bit for the sign, <span class="math inline">\(n_e\)</span> bits for the exponent, and <span class="math inline">\(n_m\)</span> bits for the mantissa, so <span class="math inline">\(n=1+n_e+n_m\)</span>.</p>
<p>Here are the steps to convert a number <span class="math inline">\(x\)</span> into its <span class="math inline">\(n\)</span>-bit floating point representation.</p>
<ul>
<li>Given some number <span class="math inline">\(x\)</span>, get its modified scientific notation form <span class="math inline">\(x = (-1)^s \cdot (1+m) \cdot 2^e\)</span>.
<ul>
<li>Determine the sign of <span class="math inline">\(x\)</span>. If negative, set the sign bit to <span class="math inline">\(s=1\)</span>, else default to <span class="math inline">\(s=0\)</span>. Set <span class="math inline">\(x = |x|\)</span>.</li>
<li>Keep performing the operation <span class="math inline">\(x = x \ // \ 2\)</span> until <span class="math inline">\(1 \leq x \leq 2\)</span>. Keep track of the number of times you’re dividing, which is the <strong>exponent</strong> <span class="math inline">\(e\)</span>.</li>
<li>The remaining part will be some <span class="math inline">\(1 \leq x \leq 2\)</span>. Write it in the form <span class="math inline">\(x = 1 + m\)</span>, where <span class="math inline">\(m\)</span> is the mantissa.</li>
</ul></li>
<li>Convert the scientific notation form into a sequence of <span class="math inline">\(n\)</span> bits, truncating where necessary.
<ul>
<li>For reasons I’ll describe in a second, it’s good to add a <strong>bias</strong> term <span class="math inline">\(b\)</span> to the exponent <span class="math inline">\(e\)</span> before converting the exponent to binary. Let <span class="math inline">\(e'=e+b\)</span> be this modified exponent.</li>
<li>Convert each of <span class="math inline">\(e'\)</span> and <span class="math inline">\(m\)</span> into binary sequences, truncated to sizes <span class="math inline">\(n_e\)</span>, and <span class="math inline">\(n_m\)</span> respectively.</li>
<li>Concatenate these binary sequences together to get a sequence of <span class="math inline">\(n=1+n_e+n_m\)</span> total bits. By convention, assume the order of bit concatenation is the sign bit, then exponent bits, then the mantissa bits.</li>
</ul></li>
</ul>
<p>There are of course other ways you could do it, for example by storing the sequences in a different order. I’m just stating one common way it’s done.</p>
<p>Since all of this must seem like Greek, here’s a quick example. Let’s consider the number <span class="math inline">\(x=15.25\)</span>. We’ll represent it using <span class="math inline">\(n=8\)</span> bits of precision, where <span class="math inline">\(n_e=4\)</span> is the number of exponent bits, <span class="math inline">\(n_m=3\)</span> is the number of precision bits, and <span class="math inline">\(b=10\)</span> is the bias.</p>
<ul>
<li>Convert <span class="math inline">\(x=15.25\)</span> to its modified scientific notation.
<ul>
<li>Since <span class="math inline">\(x \geq 0\)</span> the sign is positive, so <span class="math inline">\(s=0\)</span>.</li>
<li>Keep integer dividing <span class="math inline">\(x\)</span> by <span class="math inline">\(2\)</span> until it’s less than <span class="math inline">\(2\)</span>. It takes <span class="math inline">\(e=3\)</span> divisions before <span class="math inline">\(x&lt;2\)</span>.</li>
<li>We now have <span class="math inline">\(x = 1.90625 \cdot 2^3\)</span>. The mantissa is then <span class="math inline">\(m = (1.90625-1) = 0.90625\)</span>.</li>
<li>In modified scientific notation form we now have <span class="math inline">\(x=(-1)^0 \cdot (1 + 0.90625) \cdot 2^3\)</span>.</li>
</ul></li>
<li>Convert everything to binary.
<ul>
<li>Adding the bias to the exponent gives <span class="math inline">\(e'=3+10=13\)</span>.</li>
<li>Converting each piece to binary we get <span class="math inline">\(e' = 13 \equiv 1101\)</span>, <span class="math inline">\(m = 0.90625 \equiv 11101\)</span>.</li>
<li>Since <span class="math inline">\(m\)</span> requires more than <span class="math inline">\(n_m=3\)</span> bits to represent, truncate off the two right bits to get <span class="math inline">\(m \equiv 111\)</span>.
<ul>
<li>This truncation will cause numerical roundoff, since <span class="math inline">\(0.90625\)</span> truncates to <span class="math inline">\(0.875\)</span>. That’s an error of <span class="math inline">\(0.03125\)</span> that gets permanently lost.</li>
</ul></li>
<li>The final representation is thus <span class="math inline">\(x \equiv 0 \ 1101 \ 111\)</span>.</li>
</ul></li>
</ul>
<p>Below I show the example I just calculated. I print out both the scientific notation form and its binary representation.</p>
<div class="cell" data-execution_count="14">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>represent_as_float(<span class="fl">15.25</span>, n<span class="op">=</span><span class="dv">8</span>, n_exp<span class="op">=</span><span class="dv">4</span>, n_man<span class="op">=</span><span class="dv">3</span>, bias<span class="op">=</span><span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>scientific notation: (-1)^0 * (1 + 0.90625) * 2^3
8-bit floating point representation: 0 1101 111</code></pre>
</div>
</div>
<p>So what’s going on with the bias term <span class="math inline">\(b\)</span>? Why do we need it? The easiest answer to give is that without it, we can’t have negative exponents without having to use another sign bit for them. Consider a number like <span class="math inline">\(x=0.5\)</span>. In modified scientific notation this would look like <span class="math inline">\(x=(-1)^0 \cdot (1+0) \cdot 2^{-1} = 2^{-1}\)</span>, meaning its exponent would be <span class="math inline">\(e=-1\)</span>. Rather than have to keep yet another sign bit for the exponent, it’s easier to just add a bias term <span class="math inline">\(b\)</span> that ensures the exponent <span class="math inline">\(e'=e+b\)</span> is always non-negative. The higher the bias, the more precision we can show in the range <span class="math inline">\(-1 &lt; x &lt; 1\)</span>. The trade-off is that we lose precision for large values of <span class="math inline">\(x\)</span>.</p>
<p>On top of floats defined the way I mentioned, we also have some special numbers that get defined in a floating point system. These are <span class="math inline">\(\pm 0\)</span>, <span class="math inline">\(\pm \infty\)</span>, and <span class="math inline">\(\text{NaN}\)</span> or “not a number”. Each of these numbers is allocated its own special sequence of bits, depending on the precision.</p>
<ul>
<li><span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>: These numbers are typically represented using a biased exponent <span class="math inline">\(e'=0\)</span> (all zero bits) and a mantissa <span class="math inline">\(m=0\)</span> (all zero bits). The sign bit is used to distinguish between <span class="math inline">\(+0\)</span> and <span class="math inline">\(-0\)</span>. In our example, these would be <span class="math inline">\(+0 \equiv 0 \ 0000 \ 000\)</span> and <span class="math inline">\(-0 \equiv 1 \ 0000 \ 000\)</span>.</li>
<li><span class="math inline">\(+\infty\)</span> and <span class="math inline">\(-\infty\)</span>: These numbers are typically represented using the max allowed exponent (all one bits) and a mantissa <span class="math inline">\(m=0\)</span> (all zero bits). The sign bit is used to distinguish between <span class="math inline">\(+\infty\)</span> and <span class="math inline">\(-\infty\)</span>. In our example, these would be <span class="math inline">\(+\infty \equiv 0 \ 1111 \ 000\)</span> and <span class="math inline">\(-\infty \equiv 1 \ 1111 \ 000\)</span>.</li>
<li><span class="math inline">\(\text{NaN}\)</span>: This value is typically represented using the max allowed exponent (all one bits) and a non-zero <span class="math inline">\(m \neq 0\)</span>. The sign bit is usually not used for <span class="math inline">\(\text{NaN}\)</span> values. Note this means we can have many different sequences that all represent <span class="math inline">\(\text{NaN}\)</span>. In our example, any number of the form <span class="math inline">\(\text{NaN} \equiv \text{x} \ 1111 \ \text{xxx}\)</span> would work.</li>
</ul>
<p>So I can illustrate some points about how floating point numbers behave, I’m going to generate <em>all possible</em> <span class="math inline">\(8\)</span>-bit floats (excluding the special numbers) and plot them on a number line, similar to what I did above with the <span class="math inline">\(8\)</span>-bit signed integers. I’ll generate the floats using the using the helper function <code>gen_all_floats</code>, passing in the number of mantissa bits <code>n_man=3</code>, the number of exponent bits <code>n_exp=4</code>, and a bias of <code>bias=10</code>.</p>
<p>First, I’ll use these numbers to print out some interesting statistics of this 8-bit floating point system.</p>
<div class="cell" data-execution_count="15">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>eight_bit_floats <span class="op">=</span> gen_all_floats(n<span class="op">=</span><span class="dv">8</span>, n_man<span class="op">=</span><span class="dv">3</span>, n_exp<span class="op">=</span><span class="dv">4</span>, bias<span class="op">=</span><span class="dv">10</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Total number of 8-bit floats: </span><span class="sc">{</span><span class="bu">len</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Most negative float: </span><span class="sc">{</span><span class="bu">min</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Most positive float: </span><span class="sc">{</span><span class="bu">max</span>(eight_bit_floats)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Smallest nonzero float: </span><span class="sc">{</span><span class="bu">min</span>([x <span class="cf">for</span> x <span class="kw">in</span> eight_bit_floats <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>])<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'Machine Epsilon: </span><span class="sc">{</span><span class="bu">min</span>([x <span class="cf">for</span> x <span class="kw">in</span> eight_bit_floats <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">1</span>]) <span class="op">-</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>Total number of 8-bit floats: 120
Most negative float: -56.0
Most positive float: 56.0
Smallest nonzero float: 0.001953125
Machine Epsilon: 0.25</code></pre>
</div>
</div>
<p>We can see that this 8-bit system only contains 120 unique floats. We could practically list them all out. Just like with the integers, we see there’s a most negative float, <span class="math inline">\(-56.0\)</span>, and a most positive float, <span class="math inline">\(56.0\)</span>. The smallest float, i.e.&nbsp;the one closest to <span class="math inline">\(0\)</span>, is <span class="math inline">\(0.001953125\)</span>. Notice how much more precision the smallest float has than the largest ones do. The largest ones are basically whole numbers, while the smallest one has nine digits of precision. Evidently, floating point representations give much higher precision to numbers close to zero than to numbers far away from zero.</p>
<p>What happens if you try to input a float larger than the max, in this case <span class="math inline">\(56.0\)</span>? Typically it will <strong>overflow</strong>. This will result in either the system raising an error, or the number getting set to <span class="math inline">\(+\infty\)</span>, in a sense getting “rounded up”. Similarly, for numbers more negative than the min, in this case <span class="math inline">\(-56.0\)</span>, either an overflow error will be raised, or the number will get “rounded down” to <span class="math inline">\(-\infty\)</span>.</p>
<p>You have to be careful in overflow situations like this, especially when you don’t know for sure which of these your particular system will do. It’s amusing to note that python will raise an overflow error, but numpy will round to <span class="math inline">\(\pm \infty\)</span>. Two different conventions to worry about. Just as amusing, when dealing with signed integers, it’s numpy that will raise an error if you overflow, while python won’t care. One of those things…</p>
<p>What happens when you try to input a float smaller than the smallest value, in this case <span class="math inline">\(0.001953125\)</span>? In this case, the number is said to <strong>undeflow</strong>. Usually underflow won’t raise an error. The number will pretty much always just get set to <span class="math inline">\(+0\)</span> (or <span class="math inline">\(-0\)</span>). This is again something you have to worry about, especially if you’re dealing with small numbers in denominators, where they can lead to division by zero errors which <em>do</em> get raised.</p>
<p>Overflow and underflow errors are some of the most common numerical bugs that occur in deep learning, and usually result from not handling floats correctly to begin with.</p>
<p>I also printed out a special value called the <strong>machine epsilon</strong>. The machine epsilon, denoted <span class="math inline">\(\varepsilon_m\)</span>, is defined as the smallest value in a floating point system that’s larger than <span class="math inline">\(1\)</span>. In some sense, <span class="math inline">\(\varepsilon_m\)</span> is a proxy for how finely you can represent numbers in a given <span class="math inline">\(n\)</span>-bit floating point system. The smaller <span class="math inline">\(\varepsilon_m\)</span> the more precisely you can represent numbers, i.e.&nbsp;the more decimal places of precision you get access to. In our case, we get <span class="math inline">\(\varepsilon_m=0.25\)</span>. This means numbers in 8-bit floating point tend to be <span class="math inline">\(0.25\)</span> apart from each other on average, which means we can represent numbers in this system only with a measly 2-3 digits of precision.</p>
<p>With these numbers in hand let’s now plot their distribution on the number line. Compare with the plot of the signed integers I did above.</p>
<div class="cell" data-execution_count="16">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>plot_number_dist(eight_bit_floats, title<span class="op">=</span><span class="st">'Distribution of 8-bit Floats'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="numerical-computing_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Notice how different this plot is from the ones for the signed integers. With the integers, the points were equally spaced. Now points close to <span class="math inline">\(0\)</span> are getting represented much closer together than points far from <span class="math inline">\(0\)</span>. There are <span class="math inline">\(74\)</span> of the <span class="math inline">\(120\)</span> total points showing up just in the range <span class="math inline">\([-1,1]\)</span>. That’s over half!. Meanwhile, only <span class="math inline">\(22\)</span> points total show up in the combined ranges of <span class="math inline">\([-60,-10]\)</span> and <span class="math inline">\([10,60]\)</span>. Very strange.</p>
<p>Feel free to play around with different floating point systems by using different choices for <code>n</code>, <code>n_man</code>, <code>n_exp</code>, and <code>bias</code>. Be careful, however, not to make <code>n_exp</code> too large or you may crash the kernel…</p>
</section>
<section id="double-precision" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="double-precision"><span class="header-section-number">3.2.3</span> Double Precision</h3>
<p>So how does python represent floats? Python by default uses what’s called <strong>double precision</strong> to represent floats, also called <strong>float64</strong>. This means <span class="math inline">\(n=64\)</span> total bits of precision are used, with <span class="math inline">\(n_e=11\)</span>, <span class="math inline">\(n_m=52\)</span>, and bias <span class="math inline">\(b=1023=2^{10}-1\)</span>. Double precision allows for a <em>much</em> larger range of numbers than 8-bit precision does:</p>
<ul>
<li>The max value allowed is <span class="math inline">\(2^{2^{n_e}-b} = 2^{1025} \approx 10^{308}\)</span>.</li>
<li>The min value allowed is <span class="math inline">\(-2^{2^{n_e}-b} = -2^{1025} \approx -10^{308}\)</span>.</li>
<li>Numbers <em>outside</em> the range of about <span class="math inline">\([-10^{308}, 10^{308}]\)</span> will <em>overflow</em>.</li>
<li>The smallest values allowed are (plus or minus) <span class="math inline">\(2^{-b+1} = 2^{-1022} \approx 10^{-308}\)</span>.
<ul>
<li>Using subordinal numbers, the smallest values are (plus or minus) <span class="math inline">\(2^{-b-n_m+1} = 2^{-1074} \approx 10^{-324}\)</span>.</li>
</ul></li>
<li>Numbers <em>inside</em> the range of about <span class="math inline">\([-10^{-308}, 10^{-308}]\)</span> will <em>underflow</em>.
<ul>
<li>Using subordinal numbers, this range is around <span class="math inline">\([-10^{-324}, 10^{-324}]\)</span>.</li>
</ul></li>
<li>The machine epsilon is <span class="math inline">\(\varepsilon_m = 2^{-53} \approx 10^{-16}\)</span>.</li>
<li>Numbers requiring more than about 15-16 digits of precision will get truncated, resulting in numerical roundoff.</li>
<li>The special numbers <span class="math inline">\(\pm \infty\)</span>, <span class="math inline">\(\pm 0\)</span>, and <span class="math inline">\(\text{NaN}\)</span> are represented similarly as before, except using 64 bits.</li>
</ul>
<p>To illustrate the point regarding numerical roundoff, here’s what happens if we try to use double precision floating point to define the constant <span class="math inline">\(\pi\)</span> to its first <a href="https://www.wolframalpha.com/input?i=pi+to+100+digits">100 digits</a>? Notice it just gets truncated to its first 15 digits. Double precision is unable to keep track of the other 85 digits. They just get lost to numerical roundoff.</p>
<div class="cell" data-execution_count="17">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>pi <span class="op">=</span> <span class="fl">3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'pi = </span><span class="sc">{</span>pi<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>pi = 3.141592653589793</code></pre>
</div>
</div>
<p>Another thing to worry about is adding small numbers to medium to large sized numbers, e.g.&nbsp;<span class="math inline">\(10 + 10^{-16}\)</span>, which will just get rounded down to <span class="math inline">\(10.0\)</span>.</p>
<div class="cell" data-execution_count="18">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'10.0 + 1e-16 = </span><span class="sc">{</span><span class="fl">10.0</span> <span class="op">+</span> <span class="fl">1e-16</span><span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>10.0 + 1e-16 = 10.0</code></pre>
</div>
</div>
<p>Numerical roundoff is often an issue when subtracting two floats. Here’s what happens when we try to subtract two numbers that should be equal, <span class="math inline">\(x=0.1+0.2\)</span> and <span class="math inline">\(y=0.3\)</span>. Instead of <span class="math inline">\(y-x=0\)</span>, we get <span class="math inline">\(y-x \approx -5.55 \cdot 10^{-17}\)</span>. The problem comes from the calculation <span class="math inline">\(x=0.1+0.2\)</span>, which caused a slight loss of precision in <span class="math inline">\(x\)</span>.</p>
<div class="cell" data-execution_count="19">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="fl">0.1</span> <span class="op">+</span> <span class="fl">0.2</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="fl">0.3</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'y-x = </span><span class="sc">{</span>y <span class="op">-</span> x<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>y-x = -5.551115123125783e-17</code></pre>
</div>
</div>
<p>A major implication of these calculations is that you should <em>never</em> test floating points for exact equality because numerical roundoff can mess it up. If you’d tried to test something like <code>(y - x) == 0.0</code>, you’d have gotten the wrong answer. Instead, you want to test that <code>y - x</code> is less than some small number <code>tol</code>, called a <em>tolerance</em>, i.e.&nbsp;<code>abs(y - x) &lt; tol</code>.</p>
<div class="cell" data-execution_count="20">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-5</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'(y - x == 0.0) = </span><span class="sc">{</span>y <span class="op">-</span> x <span class="op">==</span> <span class="fl">0.0</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'(abs(y - x) &lt; tol) = </span><span class="sc">{</span><span class="bu">abs</span>(y <span class="op">-</span> x) <span class="op">&lt;</span> tol<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>(y - x == 0.0) = False
(abs(y - x) &lt; tol) = True</code></pre>
</div>
</div>
<p>Numerical roundoff explains why we got the weird results above when subtracting <span class="math inline">\(1.2 - 4.3\)</span>. The imperfect precision in the two numbers resulted in a numerical roundoff error, leading in the trailing <span class="math inline">\(9\)</span>s that should’ve rounded up to <span class="math inline">\(-3.1\)</span> exactly. In general, subtracting floats is one of the most dangerous operations to do, as it tends to lead to the highest loss of precision in calculations. The closer two numbers are to being equal the worse this loss of precision tends to get.</p>
<p>I mentioned that double precision has a smallest number of <span class="math inline">\(2^{-1022} \approx 10^{-308}\)</span>, but caveated that by saying that, by using a trick called <strong>subordinal numbers</strong>, we can get the smallest number down to about <span class="math inline">\(10^{-324}\)</span>. What did I mean by this? It turns out that the bits where the biased exponent <span class="math inline">\(e'=0\)</span> (i.e.&nbsp;all exponent bits are zero) go mostly unused in the standard version of double precision. By using this zero exponent and allowing the mantissa <span class="math inline">\(m\)</span> to take on all its possible values, we can get about <span class="math inline">\(2^{52}\)</span> more values (since the mantissa has 52 bits). This lets us get all the way down to <span class="math inline">\(2^{-1022} \cdot 2^{-52} = 2^{-1074} \approx 10^{-324}\)</span>.</p>
<p>Python (and numpy) by default implements double precision with subordinal numbers, as we can see.</p>
<div class="cell" data-execution_count="21">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'2 ** (-1074) = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">**</span> (<span class="op">-</span><span class="dv">1074</span>)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'2 ** (-1075) = </span><span class="sc">{</span><span class="dv">2</span> <span class="op">**</span> (<span class="op">-</span><span class="dv">1075</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>2 ** (-1074) = 5e-324
2 ** (-1075) = 0.0</code></pre>
</div>
</div>
<p>The special numbers <span class="math inline">\(\pm \infty\)</span>, <span class="math inline">\(\pm 0\)</span>, and <span class="math inline">\(\text{NaN}\)</span> are also defined in double precision. In python (and numpy) they’re given by the following commands,</p>
<ul>
<li><span class="math inline">\(\infty\)</span>: <code>float('inf')</code> or <code>np.inf</code>,</li>
<li><span class="math inline">\(-\infty\)</span>: <code>float('-inf')</code> or <code>-np.inf</code>,</li>
<li><span class="math inline">\(\pm 0\)</span>: <code>0</code>,</li>
<li><span class="math inline">\(\text{NaN}\)</span>: <code>float('nan')</code> or <code>np.nan</code>.</li>
</ul>
<div class="cell" data-execution_count="22">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"float('inf') = </span><span class="sc">{</span><span class="bu">float</span>(<span class="st">'inf'</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'np.inf = </span><span class="sc">{</span>np<span class="sc">.</span>inf<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"float('-inf') = </span><span class="sc">{</span><span class="bu">float</span>(<span class="st">'-inf'</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'-np.inf = </span><span class="sc">{</span><span class="op">-</span>np<span class="sc">.</span>inf<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'0 = </span><span class="sc">{</span><span class="dv">0</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'-0 = </span><span class="sc">{</span><span class="op">-</span><span class="dv">0</span><span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"float('nan') = </span><span class="sc">{</span><span class="bu">float</span>(<span class="st">'nan'</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'np.nan = </span><span class="sc">{</span>np<span class="sc">.</span>nan<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>float('inf') = inf
np.inf = inf
float('-inf') = -inf
-np.inf = -inf
0 = 0
-0 = 0
float('nan') = nan
np.nan = nan</code></pre>
</div>
</div>
<p>You may be curious what exactly <span class="math inline">\(\text{NaN}\)</span> (“not a number”) is and where it might show up. Basically, NaNs are used wherever values are undefined. Anytime an operation doesn’t return a sensible value it risks getting converted to NaN. One example is the operation <span class="math inline">\(\infty - \infty = \infty + (-\infty)\)</span>, which mathematically doesn’t make sense. No, it’s not zero…</p>
<div class="cell" data-execution_count="23">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"float('inf') + float('-inf') = </span><span class="sc">{</span><span class="bu">float</span>(<span class="st">'inf'</span>) <span class="op">+</span> <span class="bu">float</span>(<span class="st">'-inf'</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'np.inf - np.inf = </span><span class="sc">{</span>np<span class="sc">.</span>inf <span class="op">-</span> np<span class="sc">.</span>inf<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>float('inf') + float('-inf') = nan
np.inf - np.inf = nan</code></pre>
</div>
</div>
<p>I’ll finish this section by mentioning that there are two other floating point representations worth being aware of: <strong>single precision</strong> (or <strong>float32</strong>), and <strong>half precision</strong> (or <strong>float16</strong>). Single precision uses 32 bits to represent a floating point number. Half precision uses 16 bits. It may seem strange to even bother having these less-precise precisions lying around, but they do have their uses. For example, half precision shows up in deep learning as a more efficient way to represent the weights of a neural network. Since half precision floats only take up 25% as many bits as default double precision floats do, using them can yield a 4x reduction in model memory sizes. We’ll see more on this later.</p>
</section>
<section id="common-floating-point-pitfalls" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="common-floating-point-pitfalls"><span class="header-section-number">3.2.4</span> Common Floating Point Pitfalls</h3>
<p>To cap this long section on floats, here’s a list of common pitfalls people run into when working with floating point numbers, and some ways to avoid each one. This is probably the most important thing to take away from this section. You may find it helpful to reference later on. See this <a href="https://www.codeproject.com/Articles/29637/Five-Tips-for-Floating-Point-Programming">post</a> for more information.</p>
<ol type="1">
<li>Numerical overflow: Letting a number blow up to infinity (or negative infinity)
<ul>
<li>Clip numbers from above to keep them from being too large</li>
<li>Work with the log of the number instead</li>
<li>Make sure you’re not dividing by zero or a really small number</li>
<li>Normalize numbers so they’re all on the same scale</li>
</ul></li>
<li>Numerical underflow: Letting a number spiral down to zero
<ul>
<li>Clip numbers from below to keep them from being too small</li>
<li>Work with the exp of the number instead</li>
<li>Normalize numbers so they’re all on the same scale</li>
</ul></li>
<li>Subtracting floats: Avoid subtracting two numbers that are approximately equal
<ul>
<li>Reorder operations so approximately equal numbers aren’t nearby to each other</li>
<li>Use some algebraic manipulation to recast the problem into a different form</li>
<li>Avoid differencing squares (e.g.&nbsp;when calculating the standard deviation)</li>
</ul></li>
<li>Testing for equality: Trying to test exact equality of two floats
<ul>
<li>Instead of testing <code>x == y</code>, test for approximate equality with something like <code>abs(x - y) &lt;= tol</code></li>
<li>Use functions like <code>np.allclose(x, y)</code>, which will do this for you</li>
</ul></li>
<li>Unstable functions: Defining some functions in the naive way instead of in a stable way
<ul>
<li>Examples: factorials, softmax, logsumexp</li>
<li>Use a more stable library implementation of these functions</li>
<li>Look for the same function but in log form, e.g.&nbsp;<code>log_factorial</code> or <code>log_softmax</code></li>
</ul></li>
<li>Beware of NaNs: Once a number becomes NaN it’ll always be a NaN from then on
<ul>
<li>Prevent underflow and overflow</li>
<li>Remove missing values or replace them with finite values</li>
</ul></li>
</ol>
</section>
</section>
<section id="array-computing" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="array-computing"><span class="header-section-number">3.3</span> Array Computing</h2>
<p>In machine learning and most of scientific computing we’re not interested in operating on just single numbers at a time, but many numbers at a time. This is done using <em>array operations</em>. The most popular library in python for doing numerical computation on arrays is numpy.</p>
<p>Why not just do numerical computations in base python? After all, if we have large arrays of data we can just put them in a list. Consider the following example. Suppose we have two tables of data, <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span>. Each table has <span class="math inline">\(m=5\)</span> rows and <span class="math inline">\(n=3\)</span> columns. The rows represent samples, e.g.&nbsp;measured in a lab, and the columns represent the variables, or <em>features</em>, being measured, call them <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span>, and <span class="math inline">\(z\)</span>, if you like. I’ll define these two tables using python lists <code>A</code> and <code>B</code> below.</p>
<div class="cell" data-execution_count="24">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [[<span class="fl">3.5</span>, <span class="fl">18.1</span>, <span class="fl">0.3</span>],</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>     [<span class="op">-</span><span class="fl">8.7</span>, <span class="fl">3.2</span>, <span class="fl">0.5</span>],</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>     [<span class="op">-</span><span class="fl">1.3</span>, <span class="fl">8.4</span>, <span class="fl">0.2</span>],</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>     [<span class="fl">5.6</span>, <span class="fl">12.9</span>, <span class="fl">0.9</span>],</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>     [<span class="op">-</span><span class="fl">6.8</span>, <span class="fl">19.7</span>, <span class="fl">0.7</span>]]</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> [[<span class="op">-</span><span class="fl">9.7</span>, <span class="fl">12.5</span>, <span class="fl">0.1</span>],</span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>     [<span class="op">-</span><span class="fl">5.1</span>, <span class="fl">14.1</span>, <span class="fl">0.6</span>],</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>     [<span class="op">-</span><span class="fl">1.6</span>, <span class="fl">3.7</span>, <span class="fl">0.7</span>],</span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>     [<span class="fl">2.3</span>, <span class="fl">19.3</span>, <span class="fl">0.9</span>],</span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>     [<span class="fl">8.2</span>, <span class="fl">9.7</span>, <span class="fl">0.2</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Suppose we wanted to add the elements in these two tables together, index by index, like this,</p>
<p><span class="math display">\[
\begin{bmatrix}
A[0][0] + B[0][0], &amp; A[0][1] + B[0][1], &amp; A[0][2] + B[0][2] \\
A[1][0] + B[1][0], &amp; A[1][1] + B[1][1], &amp; A[1][2] + B[1][2] \\
A[2][0] + B[2][0], &amp; A[2][1] + B[2][1], &amp; A[2][2] + B[2][2] \\
A[3][0] + B[3][0], &amp; A[3][1] + B[3][1], &amp; A[3][2] + B[3][2] \\
A[4][0] + B[4][0], &amp; A[4][1] + B[4][1], &amp; A[4][2] + B[4][2] \\
\end{bmatrix}.
\]</span></p>
<p>If we wanted to do this in python, we’d have to loop over all rows and columns and place the sums one-by-one inside an array <span class="math inline">\(\mathbf{C}\)</span>, like this.</p>
<div class="cell" data-execution_count="25">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_arrays(A, B):</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>    n_rows, n_cols <span class="op">=</span> <span class="bu">len</span>(A), <span class="bu">len</span>(A[<span class="dv">0</span>])</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    C <span class="op">=</span> []</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n_rows):</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>        row <span class="op">=</span> []</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n_cols):</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> A[i][j] <span class="op">+</span> B[i][j]</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>            row.append(x)</span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>        C.append(row)</span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> C</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> add_arrays(A, B)</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'C = </span><span class="sc">{</span>np<span class="sc">.</span>array(C)<span class="sc">.</span><span class="bu">round</span>(<span class="dv">2</span>)<span class="sc">.</span>tolist()<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>C = [[-6.2, 30.6, 0.4], [-13.8, 17.3, 1.1], [-2.9, 12.1, 0.9], [7.9, 32.2, 1.8], [1.4, 29.4, 0.9]]</code></pre>
</div>
</div>
<p>Numpy makes this far easier to do. It implements <em>element-wise</em> array operatations, which allow us to operate on arrays with far fewer lines of code. In numpy, to perform the same adding operation we just did, we’d just add the two arrays together directly, <span class="math inline">\(\mathbf{A}+\mathbf{B}\)</span>.</p>
<p>To use numpy operations we have to convert data into the native numpy data type, the numpy array. Do this by wrapping lists inside the function <code>np.array</code>. Once we’ve done this, we can just add them together in one line. This will simultaneously element-wise add the elements in the array so we don’t have to loop over anything.</p>
<div class="cell" data-execution_count="26">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array(A)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array(B)</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'C = </span><span class="ch">\n</span><span class="sc">{</span>A<span class="op">+</span>B<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>C = 
[[ -6.2  30.6   0.4]
 [-13.8  17.3   1.1]
 [ -2.9  12.1   0.9]
 [  7.9  32.2   1.8]
 [  1.4  29.4   0.9]]</code></pre>
</div>
</div>
<p>This is really nice. We’ve managed to reduce a double foor loop of 8 lines of code down to just 1 line with no loops at all. Of course, there <em>are</em> loops happening in the background inside the numpy code, we just don’t see them.</p>
<p>Numpy lets us do this with pretty much any arithmetic operation we can think of. We can element-wise add, subtract, multiply, or divide the two arrays. We can raise them to powers, exponentiate them, take their logarithms, etc. Just like we would do so with single numbers. In numpy, arrays become first class citizens, treated on the same footing as the simpler numerical data types <code>int</code> and <code>float</code>. This is called <strong>vectorization</strong>.</p>
<p>Here are a few examples of different vectorized functions we can call on <code>A</code> and <code>B</code>. All of these functions are done element-wise.</p>
<div class="cell" data-execution_count="27">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A - B = </span><span class="ch">\n</span><span class="sc">{</span>A<span class="op">-</span>B<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A / B = </span><span class="ch">\n</span><span class="sc">{</span>A <span class="op">/</span> B<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A ** B = </span><span class="ch">\n</span><span class="sc">{</span>A <span class="op">**</span> B<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'np.sin(A) = </span><span class="ch">\n</span><span class="sc">{</span>np<span class="sc">.</span>sin(A)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A - B = 
[[ 13.2   5.6   0.2]
 [ -3.6 -10.9  -0.1]
 [  0.3   4.7  -0.5]
 [  3.3  -6.4   0. ]
 [-15.   10.    0.5]]
A / B = 
[[-0.36082474  1.448       3.        ]
 [ 1.70588235  0.22695035  0.83333333]
 [ 0.8125      2.27027027  0.28571429]
 [ 2.43478261  0.66839378  1.        ]
 [-0.82926829  2.03092784  3.5       ]]
A ** B = 
[[5.27885788e-06 5.25995690e+15 8.86568151e-01]
 [           nan 1.32621732e+07 6.59753955e-01]
 [           nan 2.62925893e+03 3.24131319e-01]
 [5.25814384e+01 2.71882596e+21 9.09532576e-01]
 [           nan 3.60016490e+12 9.31149915e-01]]
np.sin(A) = 
[[-0.35078323 -0.68131377  0.29552021]
 [-0.66296923 -0.05837414  0.47942554]
 [-0.96355819  0.85459891  0.19866933]
 [-0.63126664  0.32747444  0.78332691]
 [-0.49411335  0.75157342  0.64421769]]</code></pre>
</div>
</div>
<p>If vectorization just made code easier to read it would be a nice to have. But it’s more than this. In fact, vectorization also makes your code run much faster in many cases. Let’s see an example of this. I’ll again run the same operations above to add two arrays, but this time I’m going to <strong>profile</strong> the code in each case. That is, I’m going to time each operation over several runs and average the times. The ones with the lowest average time is faster than the slower one, obviously. To profile in a notebook, the easiest way is to use the <code>%timeit</code> magic command, which will do all this for you.</p>
<div class="cell" data-execution_count="28">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> A.tolist()</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> B.tolist()</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit C <span class="op">=</span> add_arrays(A, B)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>2.58 µs ± 7.26 ns per loop (mean ± std. dev. of 7 runs, 100,000 loops each)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="29">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array(A)</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.array(B)</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit C <span class="op">=</span> A <span class="op">+</span> B</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>412 ns ± 1.1 ns per loop (mean ± std. dev. of 7 runs, 1,000,000 loops each)</code></pre>
</div>
</div>
<p>Even with these small arrays the numpy vectorized array addition is almost 10 times faster than the python loop array addition. This difference becomes much more pronounced when arrays are larger. The arrays just considered are only of shape <span class="math inline">\((10,3)\)</span>. We can easily confirm this in numpy using the methods <code>A.shape</code> and <code>B.shape</code>.</p>
<div class="cell" data-execution_count="30">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A.shape = </span><span class="sc">{</span>A<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'B.shape = </span><span class="sc">{</span>B<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A.shape = (5, 3)
B.shape = (5, 3)</code></pre>
</div>
</div>
<p>Let’s try to run the add operations on much larger arrays of shape <span class="math inline">\((10000,100)\)</span>. To do this quickly I’ll use <code>np.random.rand(shape)</code>, which will sample an array with shape <code>shape</code> whose values are uniformly between 0 and 1. More on sampling in a future lesson. Running the profiling, we’re now running about 100 times faster using numpy vectorization compared to python loops.</p>
<div class="cell" data-execution_count="31">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.random.rand(<span class="dv">10000</span>, <span class="dv">100</span>)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> np.random.rand(<span class="dv">10000</span>, <span class="dv">100</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell" data-execution_count="32">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> D.tolist()</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> E.tolist()</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit F <span class="op">=</span> add_arrays(D, E)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>118 ms ± 876 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)</code></pre>
</div>
</div>
<div class="cell" data-execution_count="33">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>D <span class="op">=</span> np.array(D)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> np.array(E)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>timeit F <span class="op">=</span> D <span class="op">+</span> E</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>1.21 ms ± 32.7 µs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)</code></pre>
</div>
</div>
<p>So why is numpy vectorization so much faster than using native python loops? Because it turns out that numpy by and large doesn’t actually perform array operations in python! When array operations are done, numpy compiles them down to low-level C code and runs the operations there, where things are much faster.</p>
<p>Not only that, numpy takes advantage of very efficient linear algebra functions written over the course of decades by smart people. These functions come from low-level FORTRAN and C libraries like <a href="https://netlib.org/blas/">BLAS</a> and <a href="https://netlib.org/lapack/">LAPACK</a>. They’re hand-designed to take maximum advantage of computational speed-ups where available. These include things like parallelization, caching, and hardware vectorization operations. Native python doesn’t take advantage of <em>any</em> of these nice things. The moral is, if you want to run array operations efficiently, you need to use a numerical library like numpy or modern variants like pytorch.</p>
<section id="higher-dimensional-arrays" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="higher-dimensional-arrays"><span class="header-section-number">3.3.1</span> Higher-Dimensional Arrays</h3>
<p>The length of the shape of an array is called its <strong>dimension</strong> or <strong>rank</strong>. The arrays I showed above are examples of rank-2 or 2-dimensional arrays. We can define arrays with any number of dimensions we like. These arrays of different rank sometimes have special names:</p>
<ul>
<li>A 0-dimensional (rank-0) array is called a <strong>scalar</strong>. These are single numbers.</li>
<li>A 1-dimensional (rank-1) array is called a <strong>vector</strong>. These are arrays with only one row.</li>
<li>A 2-dimensional (rank-2) array is called a <strong>matrix</strong>. These are arrays with multiple rows.</li>
<li>An array of dimension or rank 3 or higher is called a <strong>tensor</strong>. These are arrays with multiple matrices.</li>
</ul>
<p>Here are some examples so you can see what they look like. Note I’m using <code>dtype=np.float64</code> to explicitly cast the values as float64 when defining the arrays. Numpy’s vectorization operations work for all of these arrays regardless of their shape.</p>
<div class="cell" data-execution_count="34">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>scalar <span class="op">=</span> np.float64(<span class="dv">5</span>)</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'scalar = </span><span class="sc">{</span>scalar<span class="sc">}</span><span class="ss">'</span>) <span class="co"># 0-dimensional</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>scalar = 5.0</code></pre>
</div>
</div>
<div class="cell" data-execution_count="35">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>vector <span class="op">=</span> np.array([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], dtype<span class="op">=</span>np.float64)</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'vector.shape = </span><span class="sc">{</span>vector<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'vector = </span><span class="sc">{</span>vector<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>vector.shape = (3,)
vector = [1. 2. 3.]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="36">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]], dtype<span class="op">=</span>np.float64)</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'matrix.shape = </span><span class="sc">{</span>matrix<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'matrix = </span><span class="ch">\n</span><span class="sc">{</span>matrix<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>matrix.shape = (2, 3)
matrix = 
[[1. 2. 3.]
 [4. 5. 6.]]</code></pre>
</div>
</div>
<div class="cell" data-execution_count="37">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>tensor <span class="op">=</span> np.array([[[<span class="dv">1</span>, <span class="dv">2</span>], [<span class="dv">3</span>, <span class="dv">4</span>]], [[<span class="dv">5</span>, <span class="dv">6</span>], [<span class="dv">7</span>, <span class="dv">8</span>]]], dtype<span class="op">=</span>np.float64)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'tensor.shape = </span><span class="sc">{</span>tensor<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'tensor = </span><span class="ch">\n</span><span class="sc">{</span>tensor<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>tensor.shape = (2, 2, 2)
tensor = 
[[[1. 2.]
  [3. 4.]]

 [[5. 6.]
  [7. 8.]]]</code></pre>
</div>
</div>
<p>Numpy also supports array aggregation operations as well. Suppose you have a matrix <code>A</code> and want to get the sum of the values in each row of <code>A</code>. To do this, you could use <code>np.sum(A, axis=1)</code>, where <code>axis</code> is the index of the dimension you want to sum over (the columns in this case). This will return a vector where the value at index <span class="math inline">\(i\)</span> is the sum of elements in row <span class="math inline">\(i\)</span>. To sum over <em>all</em> elements in the array, don’t pass anything to <code>axis</code>.</p>
<div class="cell" data-execution_count="38">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.array([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">3</span>], [<span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]], dtype<span class="op">=</span>np.float64)</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A = </span><span class="ch">\n</span><span class="sc">{</span>A<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'sum over all A = </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(A)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'row sums of A = </span><span class="sc">{</span>np<span class="sc">.</span><span class="bu">sum</span>(A, axis<span class="op">=</span><span class="dv">1</span>)<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A = 
[[ 1.  2.  3.]
 [-1. -2. -3.]
 [ 1.  0. -1.]]
sum over all A = 0.0
row sums of A = [ 6. -6.  0.]</code></pre>
</div>
</div>
<p>Indexing into numpy arrays like <code>A</code> is more powerful than with python lists. Instead of having to awkwardly index like <code>A[1][0]</code>, write <code>A[1, 0]</code>. To get all values in column index <code>1</code>, write <code>A[:, 1]</code>. To get just the first and last row, we could just pass the index we want in as a list like this, <code>A[[0, -1], :]</code>.</p>
<div class="cell" data-execution_count="39">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A[1, 0] = </span><span class="sc">{</span>A[<span class="dv">1</span>][<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>A[<span class="dv">1</span>, <span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A[1, 0] = -1.0 = -1.0</code></pre>
</div>
</div>
<div class="cell" data-execution_count="40">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'col 1 of A = </span><span class="sc">{</span>A[:, <span class="dv">1</span>]<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'rows 0 and -1 of A = </span><span class="ch">\n</span><span class="sc">{</span>A[[<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>], :]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>col 1 of A = [ 2. -2.  0.]
rows 0 and -1 of A = 
[[ 1.  2.  3.]
 [ 1.  0. -1.]]</code></pre>
</div>
</div>
<p>Numpy also supports Boolean masks as indexes. Suppose we want to get all the positive elements <code>x &gt;= 0</code> in <code>A</code>. We could create a mask <code>A &gt; 0</code>, and pass that into <code>A</code> as an index to pick out the positive elements only.</p>
<div class="cell" data-execution_count="41">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'mask of (A &gt;= 0) = </span><span class="ch">\n</span><span class="sc">{</span>(A <span class="op">&gt;=</span> <span class="dv">0</span>)<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'elements of (A &gt;= 0) = </span><span class="ch">\n</span><span class="sc">{</span>A[A <span class="op">&gt;=</span> <span class="dv">0</span>]<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>mask of (A &gt;= 0) = 
[[ True  True  True]
 [False False False]
 [ True  True False]]
elements of (A &gt;= 0) = 
[1. 2. 3. 1. 0.]</code></pre>
</div>
</div>
</section>
</section>
<section id="broadcasting" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="broadcasting"><span class="header-section-number">3.4</span> Broadcasting</h2>
<p>Broadcasting is a set of conventions for doing array operations on arrays with incompatible shapes. This may seem like a strange thing to do, but it turns out knowing how and when to broadcast can make your code much shorter, more readable, and efficient. All modern-day numerical libraries in python support broadcasting, including numpy, pytorch, tensorflow, etc. So it’s a useful thing to learn.</p>
<section id="motivation" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="motivation"><span class="header-section-number">3.4.1</span> Motivation</h3>
<p>Let’s start with a simple example. Suppose we have an array of floats defined below. We’d like to add 1 to every number in the array. How can we do it? One “pythonic” way might be to use a list comprehension like so. This will work just fine, but it requires going back and forth between arrays and lists.</p>
<div class="cell" data-execution_count="42">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> np.array([<span class="fl">1.</span>, <span class="fl">2.</span>, <span class="fl">3.</span>, <span class="fl">4.</span>, <span class="fl">5.</span>])</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'x = </span><span class="sc">{</span>x<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>x_plus_1 <span class="op">=</span> np.array([val <span class="op">+</span> <span class="dv">1</span> <span class="cf">for</span> val <span class="kw">in</span> x])</span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'x + 1 = </span><span class="sc">{</span>x_plus_1<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x = [1. 2. 3. 4. 5.]
x + 1 = [2. 3. 4. 5. 6.]</code></pre>
</div>
</div>
<p>What if we didn’t want to go back and forth like that? It is slow after all. Anytime numpy has to handoff back to python or vice versa it’s going to slow things down. Another thing we could try is to make a vector of ones of the same size as <code>x</code>, then add it to <code>x</code>. This is also fine, but it requires defining this extra array of ones just to add 1 to the original array.</p>
<div class="cell" data-execution_count="43">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>ones <span class="op">=</span> np.ones(<span class="bu">len</span>(x))</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>x_plus_1 <span class="op">=</span> x <span class="op">+</span> ones</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'x + 1 = </span><span class="sc">{</span>x_plus_1<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x + 1 = [2. 3. 4. 5. 6.]</code></pre>
</div>
</div>
<p>We’d <em>like</em> to be able to just add 1 to the array like we would with numbers. If <code>x</code> were a single number we’d just write <code>x + 1</code> to add one to it, right? But technically we can’t do this if <code>x</code> is an array, since <code>x</code> has shape <code>(5,)</code> and 1 is just a number with no shape. This is where broadcasting comes in. Broadcasting says let’s <em>define</em> the operation <code>x + 1</code> so that it <em>means</em> add 1 to every element of <code>x</code>.</p>
<div class="cell" data-execution_count="44">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>x_plus_1 <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'x + 1 = </span><span class="sc">{</span>x_plus_1<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>x + 1 = [2. 3. 4. 5. 6.]</code></pre>
</div>
</div>
<p>This notation has the advantage of keeping array equations simple, while at the same time keeping all operations in numpy so that they run fast.</p>
</section>
<section id="broadcasting-rules" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="broadcasting-rules"><span class="header-section-number">3.4.2</span> Broadcasting Rules</h3>
<p>Suppose now that we have two arrays <code>A</code> and <code>B</code> of arbitrary shape and we want to operate on them, e.g.&nbsp;via the operations <code>+, -, *, /, //, **</code>. Here are the general broadcasting rules, quoted directly from the <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">numpy documentation</a>.</p>
<blockquote class="blockquote">
<p><strong>Numpy Documentation</strong><br><br>When operating on two arrays, numpy compares their shapes element-wise. It starts with the trailing (i.e.&nbsp;rightmost) dimensions and works its way left. Two dimensions are <strong>compatible</strong> when <br><br>1. they are equal, or<br>2. one of them is 1 <br><br>If these conditions are not met, a <code>ValueError: operands could not be broadcast together</code> exception is thrown, indicating that the arrays have <strong>incompatible</strong> shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</p>
</blockquote>
<p>Let’s look at an example. First, suppose <code>A</code> has shape <code>(2, 2, 3)</code> and <code>B</code> has shape <code>(3,)</code>. Suppose for simplicity that they’re both arrays of all ones. Here’s what this looks like, with <code>B</code> aligned to the right.</p>
<p><span class="math display">\[\begin{align*}
A &amp;:&amp; 2, &amp; &amp; 2, &amp; &amp; 3 \\
B &amp;:&amp;   &amp; &amp;   &amp; &amp; 3 \\
\hline
C &amp;:&amp; 2, &amp; &amp; 2, &amp; &amp; 3 \\
\end{align*}\]</span></p>
<p>Here are the broadcasting steps that will take place. Note that only <code>B</code> will change in this example. <code>A</code> will stay fixed.</p>
<ul>
<li>Numpy will start in the rightmost dimension, checking if they’re equal.</li>
<li>Begin with <code>A</code> of shape <code>(2, 2, 3)</code> and <code>B</code> of shape <code>(3,)</code>.</li>
<li>In this case, the rightmost dimension is <code>3</code> in both arrays, so we have a match.</li>
<li>Moving left by one, <code>B</code> no longer has anymore dimensions, but <code>A</code> has two, each <code>2</code>. These arrays are thus compatible.</li>
<li>Numpy will now copy <code>B</code> to the left in these new dimensions until it has the same shape as <code>A</code>.
<ul>
<li>Copy values of B twice to get <code>B = [[1, 1, 1], [1, 1, 1]]</code> with shape <code>(2, 3)</code>.</li>
<li>Copy values of B twice again to get <code>B = [[[1, 1, 1], [1, 1, 1]], [[1, 1, 1], [1, 1, 1]]]</code> with shape <code>(2, 2, 3)</code>.</li>
</ul></li>
<li>The shapes of A and B are now equal. The output array <code>C</code> will have shape <code>(2, 2, 3)</code>.</li>
</ul>
<p>Let’s verify this is true on two simple arrays of ones. Let’s also print out what <code>C</code> looks like. Since only copying is taking place we should just be adding 2 arrays of ones, hence the output should sum 2 arrays of ones, giving one array <code>C</code> of twos.</p>
<div class="cell" data-execution_count="45">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.ones((<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>))</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.ones(<span class="dv">3</span>,)</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A.shape = </span><span class="sc">{</span>A<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'B.shape = </span><span class="sc">{</span>B<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> A <span class="op">+</span> B</span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'C.shape = </span><span class="sc">{</span>C<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'C = </span><span class="ch">\n</span><span class="sc">{</span>C<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A.shape = (2, 2, 3)
B.shape = (3,)
C.shape = (2, 2, 3)
C = 
[[[2. 2. 2.]
  [2. 2. 2.]]

 [[2. 2. 2.]
  [2. 2. 2.]]]</code></pre>
</div>
</div>
<p>Let’s do one more example. Suppose now that <code>A</code> has shape <code>(8, 1, 6, 1)</code> and <code>B</code> has shape <code>(7, 1, 5)</code>. Here’s a table of this case, again with <code>B</code> aligned to the right since it has the fewest dimensions.</p>
<p><span class="math display">\[\begin{align*}
A &amp;:&amp; 8, &amp; &amp; 1, &amp; &amp; 6, &amp; &amp; 1 \\
B &amp;:&amp;    &amp; &amp; 7, &amp; &amp; 1, &amp; &amp; 5 \\
\hline
C &amp;:&amp; 8, &amp; &amp; 7, &amp; &amp; 6, &amp; &amp; 5 \\
\end{align*}\]</span></p>
<p>Here are the broadcasting steps that will take place.</p>
<ul>
<li>Starting again from the right, dimensions <code>1</code> and <code>5</code> don’t match. But since <code>A</code> has a <code>1</code> rule (2) applies, so <code>A</code> will broadcast itself (i.e.&nbsp;copy its values) 5 times in this dimension to match <code>B</code>.</li>
<li>Moving left by one we get <code>6</code> and <code>1</code>. Now <code>B</code> will broadcast itself in this dimension 6 times to match <code>A</code>.</li>
<li>Moving left again we get <code>1</code> and <code>7</code>. Now <code>A</code> will broadcast itself in this dimension 7 times to match <code>B</code>.</li>
<li>Last, we get <code>8</code> in <code>A</code> and <code>B</code> is out of dimensions, so <code>B</code> will broadcast itself 8 times to match <code>A</code>.</li>
<li>The shapes of <code>A</code> and <code>B</code> are now equal. The output <code>C</code> thus has shape <code>(8, 7, 6, 5)</code>.</li>
</ul>
<p>Here again is an example on two arrays of ones. Verify that the shapes come out right.</p>
<div class="cell" data-execution_count="46">
<details>
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> np.ones((<span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">1</span>))</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> np.ones((<span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">5</span>))</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'A.shape = </span><span class="sc">{</span>A<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'B.shape = </span><span class="sc">{</span>B<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> A <span class="op">/</span> B</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f'C.shape = </span><span class="sc">{</span>C<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-stdout">
<pre><code>A.shape = (8, 1, 6, 1)
B.shape = (7, 1, 5)
C.shape = (8, 7, 6, 5)</code></pre>
</div>
</div>
<p>That’s pretty much all there is to broadcasting. It’s a systematic way of trying to copy the dimensions in each array until they both have the same shape. All this broadcasting is done under the hood for you when you try to operate on two arrays of different shapes. You don’t need to do anything but understand <em>how</em> the arrays get broadcast together so you can avoid errors in your calculations, sometimes very subtle errors. This can be a bit confusing to understand if you’re not used to it. We’ll practice broadcasting a good bit so you can get the hang of it.</p>
</section>
</section>
<section id="floating-point-operations" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="floating-point-operations"><span class="header-section-number">3.5</span> Floating Point Operations</h2>
<p>Typically, when working with numerical algorithms it’s conventional to measure the time the algorithm takes to run using <strong>floating point operations</strong>, or <strong>FLOPS</strong> for short. The main difference between counting the FLOPs of a program and computing its algorithmic runtime is that we only count <em>floating point</em> operations when counting FLOPs. We don’t count lines that perform logical operations or lines that define a statement like a for loop or a function signature. Other than that, counting FLOPS works exactly the same way as computing algorithmic runtime, including the use of the big-O notation.</p>
<p>Let’s do an example. Suppose we want to element-wise multiply two vectors <code>x</code> and <code>y</code> each of size <span class="math inline">\(n\)</span>. If we didn’t use numpy, we might implement this using the following simple function:</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a> <span class="kw">def</span> element_wise_multiply(x, y):</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(x)</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>    z <span class="op">=</span> [x[i] <span class="op">*</span> y[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> z</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To calculate the FLOPS of this function, we need to figure out how many operations of the type <code>+, -, *, /, //, %</code> are being executed as the function runs over the input. First, note that the function signature, the definition for <code>n</code>, and the return statement aren’t floating point operations. The only line doing any floating point is</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> [x[i] <span class="op">*</span> y[i] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>This line is really a short-hand way of writing the following loop:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    z[i] <span class="op">=</span> x[i] <span class="op">*</span> y[i]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, the definition of <code>z</code> isn’t actually a FLOP since the <code>*</code> is being used to define a list of length <code>n</code>. The only FLOPS evidently being performed are each of the <code>z[i] = x[i] * y[i]</code> operations. How many of these are being done? Since we’re doing one each time we run through the loop, we’re evidently doing <code>n</code> total FLOPS.</p>
<p>Thus, this simple element-wise multiplication algorithm us running in exactly <span class="math inline">\(n\)</span> FLOPS. Just as we’d do for algorithmic runtime, we’d write this using big-O notation by saying the algorithm does <span class="math inline">\(O(n)\)</span> total FLOPS.</p>
<p>As a <em>very</em> rough rule of thumb, algorithms that use less than <span class="math inline">\(O(n^3)\)</span> FLOPS are considered “fast”, and algorithms that use at or above <span class="math inline">\(O(n^3)\)</span> FLOPS are considered slow. Worst of all are algorithms that require exponentially many FLOPS or worse. Those are usually recursive in nature, often involving trees or graphs.</p>
<p>Just as with algorithmic runtime and memory, take these asymptotic estimates with something of a grain of salt. They’re just abstractions. At the end of the day what we <em>really</em> care about is how fast our code runs and how much memory it’s using on our machines. Remember, asymptotic estimates ignore the constant factor out front of the leading term, which can often be a big deal in practice. When in doubt, always profile your code to figure out which lines are running slow and think about how you can speed them up.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation column-page-right">
  <div class="nav-page nav-page-previous">
      <a href="../notebooks/basic-math.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Basic Math</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../notebooks/calculus.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Calculus</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>